先把现在这套求解栈梳理一遍，不然谁看谁头大。

---

## 1. 现在的整体求解框架

从外到内大致是：

1. **时间推进 / timestepper**

   * 用 `timestepper._advance_one_step_nonlinear_*` 做每一步 `t_old -> t_new`。
   * 每一步把“当前步的未知量向量 `u`”扔给一个**全局非线性求解器**。

2. **全局非线性求解层：`solve_nonlinear(ctx, u0)`**

   * 由 `cfg.nonlinear.backend` 决定用哪条分支：

     * `backend: "scipy"` → 走 SciPy 的 `newton_krylov`
     * `backend: "petsc"` / `"snes"` / `"petsc_snes"` → 走 PETSc SNES
   * 返回统一的 `NonlinearSolveResult`：

     * `u`：本步收敛后的未知量
     * `diag`：`NonlinearDiagnostics`（包含迭代数、残差、extra 指标）

3. **线性层**

   * **SciPy 分支**：线性求解完全被 `scipy.optimize.newton_krylov` 内部打包：

     * 内部调用 SciPy 的 Krylov solver（例如 `lgmres`），你只通过：

       * `nonlinear.krylov_method`
       * `nonlinear.inner_maxiter`
         控制它。
   * **PETSc 分支**：线性求解交给 PETSc:

     * SNES 外面包着 `KSP`：

       * 类型由 `petsc.ksp_type` 控制（`preonly`, `gmres` 等）
       * 预条件器由 `petsc.pc_type` 控制（`lu`, `ilu`, `jacobi` 等）
     * Jacobian/预条件矩阵：

       * `jacobian_mode: "fd"`：dense FD（玩具 / debug）
       * `jacobian_mode: "mfpc_aijA"`：`J` = matrix-free，`P` = 用 `A(u)` 组装出来的 AIJ 预条件矩阵
       * `jacobian_mode: "mfpc_sparse_fd"`：`J` = matrix-free，`P` = 稀疏 FD Jacobian（按 pattern + 分组差分）

所以目前真正“干重活”的线性层只有两套：
**SciPy Krylov** & **PETSc KSP**。

---

## 2. `nonlinear:` 区块字段梳理

你 YAML 里这段：

```yaml
nonlinear:
  enabled: true  # enable global nonlinear solve
  backend: "petsc"  # options: "scipy" | "petsc" | "snes" | "petsc_snes"
  solver: "newton_krylov"  # SciPy-only (ignored by PETSc backend)
  krylov_method: "lgmres"  # SciPy-only Krylov method
  max_outer_iter: 20  # SNES/Newton max outer iterations
  inner_maxiter: 30  # SciPy inner Krylov max iterations
  f_rtol: 1.0e-6  # nonlinear relative tolerance
  f_atol: 1.0e-8  # nonlinear absolute tolerance
  use_scaled_unknowns: true  # scale unknowns by layout scales
  use_scaled_residual: false  # scale residuals by block norms (false is often more robust)
  residual_scale_floor: 1.0e-12  # minimum residual scale
  verbose: false  # verbose nonlinear logging
  log_every: 5  # log every N iterations
```

### 2.1 字段分类：SciPy 用 / PETSc 用

| 字段名                    | SciPy backend        | PETSc backend | 作用                                                        |
| ---------------------- | -------------------- | ------------- | --------------------------------------------------------- |
| `enabled`              | ✅                    | ✅             | 是否启用“全局非线性求解”（否则 timestepper 不调全局 Newton）                 |
| `backend`              | ✅                    | ✅             | 选择 `scipy` 还是 `petsc`（`snes` / `petsc_snes` 当别名用就行）       |
| `solver`               | ✅（只支持 newton_krylov） | ⛔ 忽略          | SciPy 非线性求解器类型，目前实际就一个                                    |
| `krylov_method`        | ✅                    | ⛔ 忽略          | 传给 `scipy.optimize.newton_krylov` 的 Krylov 名字（`lgmres` 等） |
| `inner_maxiter`        | ✅                    | ⛔ 忽略          | SciPy 内层 Krylov 最大迭代步数                                    |
| `max_outer_iter`       | ✅                    | ✅             | SciPy：外层 Newton 最大迭代数；PETSc：SNES `max_it`                 |
| `f_rtol`               | ✅                    | ✅             | 非线性相对容差，Scipy/SNES 共用                                     |
| `f_atol`               | ✅                    | ✅             | 非线性绝对容差                                                   |
| `use_scaled_unknowns`  | ✅                    | ✅             | 把 u 按 layout scale 标准化再丢给求解器                              |
| `use_scaled_residual`  | ✅                    | ✅             | 对 residual 做 block-level scaling（你现在基本都设为 false，比真实更稳）    |
| `residual_scale_floor` | ✅                    | ✅             | scaling 下限，用来避免除 0/极小数                                    |
| `verbose`              | ✅                    | ✅             | 控制日志输出（SciPy/PETSc 自己的 wrapper）                           |
| `log_every`            | ✅                    | ✅             | 每隔多少步打印一次迭代信息                                             |

**简单人话版：**

* **公共必需**：`enabled`, `backend`, `max_outer_iter`, `f_rtol`, `f_atol`, `use_scaled_unknowns`, `use_scaled_residual`, `residual_scale_floor`, `verbose`, `log_every`
* **SciPy 专用**：`solver`, `krylov_method`, `inner_maxiter`
* **PETSc 专用**：都在下面的 `petsc:` 块里，不在 `nonlinear:` 里设置

---

## 3. `petsc:` 区块字段梳理

你现在写的是：

```yaml
petsc:
  snes_type: newtonls
  linesearch_type: l2
  jacobian_mode: mfpc_sparse_fd

  ksp_type: preonly      # 或 gmres
  pc_type: lu
  max_it: 10            # 线性迭代别再 1
  rtol: 1.0e-8
  atol: 1.0e-12
  restart: 50
  monitor: false
  snes_monitor: false
```

按用途拆一下：

### 3.1 SNES 相关

| 字段名               | 用途                                                                       |
| ----------------- | ------------------------------------------------------------------------ |
| `snes_type`       | SNES 外层算法，目前你用 `newtonls`（线搜索 Newton）。别瞎改，先保持这个。                         |
| `linesearch_type` | 线搜索类型：`bt`（backtracking），`l2`（L2 projected）。你现在 `l2` 用得还算稳定。             |
| `jacobian_mode`   | 我们新加的 Jacobian/PC 模式：`fd` / `mfpc_aijA` / `mfpc_sparse_fd`（支持一些大小写 & 别名） |
| `snes_monitor`    | 是否让 PETSc 打 SNES 的 monitor 信息（通常关，避免刷屏）。                                 |

### 3.2 KSP / 线性求解相关

| 字段名        | 用途                                                              |
| ---------- | --------------------------------------------------------------- |
| `ksp_type` | 线性求解器类型：`preonly`（只用 PC，一步解），`gmres`（最常用），也可以 `bicg`, `cg` 等    |
| `pc_type`  | 预条件器类型：串行调试可以用 `lu`，大规模/并行后建议 `ilu` / `bjacobi` 等               |
| `max_it`   | KSP 最大迭代步数。`ksp_type=preonly` 时这个基本没用，因为本质上只做一次 factor + solve。 |
| `rtol`     | 线性相对容差。                                                         |
| `atol`     | 线性绝对容差。                                                         |
| `restart`  | 对 GMRES 而言重启步数（比如 50）。                                          |
| `monitor`  | KSP monitor 打印开关。                                               |

### 3.3 预条件矩阵 / 稀疏相关（你已经加上去了）

在新版代码里还有：

* `precond_drop_tol`：预条件矩阵的小值截断阈值（你现在很多时候设 0，不做截断）
* `precond_max_nnz_row`：每行允许的最大非零个数（>0 时会裁剪最小的那些）

这些会体现在 `diag.extra["precond_diag"]` 里（`nnz_sum`, `nnz_max_row` 之类）。

---

## 4. 当前“非线性求解模式”一览

把你现有的模式整理成几个明确的“档位”，方便以后切换：

### 4.1 SciPy 全局 Newton–Krylov 模式

```yaml
nonlinear:
  enabled: true
  backend: "scipy"
  solver: "newton_krylov"
  krylov_method: "lgmres"    # 或其他 SciPy 支持的方法
  inner_maxiter: 30
  max_outer_iter: 50
  f_rtol: 1.0e-6
  f_atol: 1.0e-8
  use_scaled_unknowns: true
  use_scaled_residual: false
  residual_scale_floor: 1.0e-12
  verbose: false
  log_every: 5

petsc: {}  # 可以保留默认，反正不会用到
```

特点：

* **完全靠 SciPy**，不需要 PETSc。
* 适合开发、调试、小规模问题。
* Jacobian 是 SciPy 自己内部做 matrix-free FD。

---

### 4.2 PETSc SNES + FD Jacobian（玩具 / debug 模式）

```yaml
nonlinear:
  enabled: true
  backend: "petsc"
  max_outer_iter: 20
  f_rtol: 1.0e-6
  f_atol: 1.0e-8
  use_scaled_unknowns: true
  use_scaled_residual: false
  residual_scale_floor: 1.0e-12
  verbose: false
  log_every: 5

petsc:
  snes_type: newtonls
  linesearch_type: bt        # 或 l2
  jacobian_mode: fd          # dense FD Jacobian

  ksp_type: preonly
  pc_type: lu
  max_it: 1
  rtol: 1.0e-8
  atol: 1.0e-12
  restart: 50
  monitor: false
  snes_monitor: false
```

特点：

* Jacobian 直接 dense FD，PC 就是这个 dense 矩阵本身。
* **非常慢**，只适合作“对比 / 验证”，不要拿它去跑万级未知量。

---

### 4.3 PETSc SNES + `P = AIJ(A(u))`（`mfpc_aijA` 模式，2B-1）

推荐你现在的“基础工作”模式：

```yaml
nonlinear:
  enabled: true
  backend: "petsc"
  max_outer_iter: 20
  f_rtol: 1.0e-6
  f_atol: 1.0e-8
  use_scaled_unknowns: true
  use_scaled_residual: false
  residual_scale_floor: 1.0e-12
  verbose: false
  log_every: 5

petsc:
  snes_type: newtonls
  linesearch_type: l2
  jacobian_mode: mfpc_aijA

  ksp_type: preonly      # 调试/小规模时直接 LU
  pc_type: lu
  max_it: 10
  rtol: 1.0e-8
  atol: 1.0e-12
  restart: 50
  monitor: false
  snes_monitor: false
  precond_drop_tol: 0.0
  precond_max_nnz_row: null    # 或者不写
```

特点：

* `J` 是 matrix-free，SMW 由 `_MFJacShellCtx` 负责。
* `P` 用 `A(u)` 组装的 AIJ 矩阵做 PC（“像 Jacobian 但没那么严格”）。
* 相比纯 FD，要少很多 residual 调用，稳定性不错，现在你的真实 case 已经能愉快跑起来。

---

### 4.4 PETSc SNES + 稀疏 FD Jacobian 预条件器（`mfpc_sparse_fd`，2B-2）

这是“偏科研向”的模式，用来在 Ng 较大时减轻 Jac 代价：

```yaml
nonlinear:
  enabled: true
  backend: "petsc"
  max_outer_iter: 20
  f_rtol: 1.0e-6
  f_atol: 1.0e-8
  use_scaled_unknowns: true
  use_scaled_residual: false
  residual_scale_floor: 1.0e-12
  verbose: false
  log_every: 5

petsc:
  snes_type: newtonls
  linesearch_type: l2
  jacobian_mode: mfpc_sparse_fd

  ksp_type: gmres       # 这时更建议 GMRES + ILU，发挥稀疏 Jacobian 优势
  pc_type: ilu
  max_it: 50
  rtol: 1.0e-8
  atol: 1.0e-12
  restart: 50
  monitor: false
  snes_monitor: false
  precond_drop_tol: 0.0
  precond_max_nnz_row: 80   # 举例，真实值以后再调
```

特点：

* `P` 用 `build_sparse_fd_jacobian` + pattern + 分组 FD 构造，**Jacobian 更新只需要少量 residual 调用**。
* 小规模案例已通过：

  * 与 dense FD Jacobian 对比
  * 冒烟测试
* 大案例上现在的表现：**数学上没问题，数值上还要调**（特别是 linesearch、pc_type、drop_tol、lag 策略等），这就是后面专门做“性能 & 稳健性”的 Stage 的事。

---

## 5. 最后给你一个“配置记忆法”

懒人总结：

* 想用 SciPy：

  ```yaml
  nonlinear.backend: scipy
  nonlinear.solver: newton_krylov
  nonlinear.krylov_method: lgmres
  ```

* 想用 PETSc 最简单可用 SNES：

  ```yaml
  nonlinear.backend: petsc
  petsc.jacobian_mode: mfpc_aijA
  petsc.ksp_type: preonly
  petsc.pc_type: lu
  ```

* 想玩高级稀疏 FD + PC，Ng 大一点时：

  ```yaml
  nonlinear.backend: petsc
  petsc.jacobian_mode: mfpc_sparse_fd
  petsc.ksp_type: gmres
  petsc.pc_type: ilu
  ```

其它所有字段都是围绕这三个开关在“微调难度级别”，核心结构你现在已经是清楚且跑得通的，只是 YAML 里注释之后再稍微整理一下就不会有“看着乱”的感觉了。
