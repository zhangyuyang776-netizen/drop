挺好，你总算给自己放了个阶段性复盘的机会，不是一股脑儿把代码往前糊。下面我帮你把 **Step 1–10 当前框架**系统梳理一遍，看看这堆零件现在已经长成了什么东西。

---

## 0. 大局观：你现在已经有什么？

到 Step 10 为止，你已经有了一个**1D 球对称、多组分、无化学反应**的传输框架的「骨架」：

* 统一的 **CaseConfig / Grid1D / State / Props / Layout** 结构
* 完整的 **气相物性模块（Cantera）** & **液相物性模块（CoolProp）**
* 气相：

  * `Tg` 能量方程：扩散（隐式）+ Stefan 对流（显式），SciPy 线性系统
  * `Yg` 单物种方程：扩散（隐式）+ Stefan 对流（显式），SciPy 线性系统
* 液相：

  * `Tl` 导热方程：内部导热 + 中心对称 + 界面 Dirichlet（用 Ts 约束），SciPy 线性系统
* 所有通量 / 线性系统都走统一的约定：
  `radial_normal = +er，flux_sign = outward_positive，q = -k dT/dr，J = -ρ D ∂Y/∂r`

缺啥以后再说，先看你已经搞定的东西。

---

## 1. 核心基础层（Step 1–5）

### 1.1 `core.types`：全局数据结构

**主要结构：**

* `CaseConfig`

  * `case, paths, geometry, time, discretization, conventions, physics, species, output, constraints`
  * 每个模块都用这个拿各种参数 & 约定：

    * `geometry.N_l, N_g, R_d, R_inf`
    * `time.dt`
    * `discretization.theta`
    * `conventions.radial_normal / flux_sign / heat_flux_def / evap_sign`
    * `species.gas_species / liq_species`
    * `physics.interface.equilibrium.coolprop.*` 等等

* `Grid1D`

  * 字段：

    * `Nl, Ng, Nc`
    * `r_c[Nc]`：cell center
    * `r_f[Nc+1]`：faces
    * `A_f[Nc+1]`：4πr²
    * `V_c[Nc]`：体积
    * `iface_f`：界面所在 face index
    * `liq_slice = slice(0, Nl)`
    * `gas_slice = slice(Nl, Nc)`

* `State`

  * `Tg[Ng]`
  * `Yg[Ns_g, Ng]`
  * `Tl[Nl]`
  * `Yl[Ns_l, Nl]`
  * `Ts`：界面 T
  * `mpp`：质量通量（kg/m²/s）
  * `Rd`：液滴半径

* `Props`

  * 气相：

    * `rho_g[Ng], cp_g[Ng], k_g[Ng], D_g[Ns_g, Ng]`
  * 液相：

    * `rho_l[Nl], cp_l[Nl], k_l[Nl]`
  * 其他额外字段由 `aggregator` 管

这些结构是后面所有 `physics` / `assembly` 模块的共同语言。

---

### 1.2 `core.layout.UnknownLayout`

目的：把「物理量」映射到大线性系统里的索引。

当前主要用到两种 dummy 布局：

* 只解 Tg：

  * `layout.has_block("Tg") = True`
  * `layout.idx_Tg(ig) = ig`
  * `n_dof() = Ng`

* 只解 Yg 单物种 / 只解 Tl：

  * `layout.idx_Yg(k_spec, ig) = ig`（测试用：把整条 Yk 看成一个标量问题）
  * `layout.idx_Tl(il) = il`
  * `n_dof() = Nl` 或 `Ng`

后面你要做真正多物种 / 耦合系统，只需要把这些 dummy layout 换成完整的 layout 即可，物理模块不用动。

---

### 1.3 物性层

#### `properties/gas.py`

* `GasPropertiesModel`

  * 持有 `ct.Solution`，`P_ref`，`species_names` 等

* `build_gas_model(cfg)`

  * 从 `cfg.paths.gas_mech` 读 Cantera 机理
  * 记录 `gas_species_names` 和 `name_to_idx`

* `compute_gas_props(model, state, grid) -> (core, extra)`

  输入：

  * `state.Tg[Ng]`
  * `state.Yg[Ns, Ng]`（**必须是机理长度 & 每列归一化**）
  * `grid.Ng`

  输出：

  * `core`：

    * `rho_g[Ng]`
    * `cp_g[Ng]`
    * `k_g[Ng]`
    * `D_g[Ns_g, Ng]`  ← Step 9.1 时补齐的
  * `extra`：

    * `h_g[Ng]`
    * `h_gk[Ns_g, Ng]`

  用法：

  * 被 `properties/aggregator.build_props_from_state` 调用，构造 `Props`。

#### `properties/liquid.py` + `aggregator.py`

* `build_liquid_model(cfg)`：

  * 用 CoolProp & `cfg.physics.interface.equilibrium.coolprop.fluids` + `cfg.species.liq_species` 绑定液相物种
* `compute_liquid_props(model, state, grid)`：

  * 给出 `rho_l, cp_l, k_l` 等
* `aggregator.build_props_from_state(...)`：

  * 调 `compute_gas_props` + `compute_liquid_props`
  * 汇总为一个 `Props`，给后续所有 `physics/assembly` 用

---

## 2. 气相能量方程：`Tg`（Step 6–8）

### 2.1 `physics/flux_gas.py`（Step 7 + Step 9.2）

#### `compute_gas_diffusive_flux_T(...)`

输入：

* `cfg, grid, props, Tg[Ng]`

输出：

* `q_cond[Nc+1]`，含义：
  `q_f = -k * dT/dr`，**outward 正**，只对气相内部 faces + 外边界赋值

逻辑：

* 内部气相 faces（cell ig, ig+1 之间）：

  * `k_face = (k_g[ig] + k_g[ig+1]) / 2`
  * `dT/dr ≈ (Tg[ig+1] - Tg[ig]) / (rR - rL)`
  * `q_cond[f] = -k_face * dT/dr`
* 界面 face：Step 7/9 里是占位 `0.0`，真正界面耦合放 interface 模块
* 外边界：用 ghost `T_inf` 做 Dirichlet，对应 Neumann-兼容写法

#### `compute_gas_diffusive_flux_Y(...)`（Step 9.2）

输入：

* `cfg, grid, props`
* `Yg[Ns_g, Ng]`

  * 每列归一化
* `props.D_g[Ns_g, Ng]`
* `props.rho_g[Ng]`

输出：

* `J_diff[Ns_g, Nc+1]`：

  * `J_k = -ρ D_k ∂Y_k/∂r`，outward 正
  * 内部气相 faces 有值，界面 & 外边界当前是 `0` 占位

这是之后物种方程里的扩散通量来源。

---

### 2.2 `physics/stefan_velocity.py`（Step 8）

`compute_stefan_velocity(cfg, grid, props, state) -> StefanVelocity`

输入：

* `state.mpp`：质量通量（kg/m²/s），**约定：mpp>0 为液→气蒸发**
* `state.Rd`：液滴半径
* `props.rho_g[Ng]`
* `grid.r_c, r_f, gas_slice, iface_f`

输出：

* `u_cell[Nc]`

  * 液相 cell 为 0
  * 气相 cell：
    `u(r) = mpp * Rd² / (ρ_g(r) * r²)`，outward 正
* `u_face[Nc+1]`

  * 界面 face：用第一层气相 ρ
  * 内部气相 face：用两侧 ρ 均值 + face 半径
  * 外边界 face：用最外层ρ + r_f[-1]

这个模块给气相对流速度，供 `flux_convective_gas` 用。

---

### 2.3 `physics/flux_convective_gas.py`（Step 8 + 9.3）

#### `compute_gas_convective_flux_T(...)`

输入：

* `cfg, grid, props`
* `Tg[Ng]`
* `u_face[Nc+1]`（来自 Stefan velocity）

输出：

* `q_conv[Nc+1]`，定义：
  `q_conv = ρ u cp T_up`，outward 正

内部 faces：

* ρ_f, cp_f 用左右 cell 平均
* Upwind：

  * `u>=0` 用左 cell Tg
  * `u<0` 用右 cell Tg

边界：

* 界面：0 占位（将来 interface BC）
* 外边界：upwind，如果 `u_out<0` 用 `T_inf` 作为上游

#### `compute_gas_convective_flux_Y(...)`（Step 9.3）

输入：

* `cfg, grid, props`
* `Yg[Ns_g, Ng]`
* `u_face[Nc+1]`

输出：

* `J_conv[Ns_g, Nc+1]`，定义：
  `J_i = ρ u Y_i_up`，outward 正

内部 faces：

* `ρ_f` 用左右 cell 平均
* Upwind 同上：`u>=0` 用左侧 Y，`u<0` 用右侧 Y

边界：

* 界面：0 占位
* 外边界：目前 MVP 用「最外层 cell 组分」当近似远场：`Y_up_out = Y_last`

将来你可以换成真正 `Y_inf`。

---

### 2.4 `assembly/build_system_SciPy.py`（Step 6 → Step 8 升级）

`build_transport_system(cfg, grid, layout, state_old, props, dt) -> (A, b)`

目标：**只装 Tg 方程**，用于 SciPy 线性求解。

输入：

* `cfg`：只用到 `theta=1`、`T_inf`
* `grid`
* `layout`：必须有 `idx_Tg(ig)`，`n_dof() == Ng`
* `state_old.Tg[Ng]`
* `props.rho_g, cp_g, k_g`
* `dt`

输出：

* `A[N×N], b[N]`，`N = Ng`

结构：

1. 时间项 + 扩散项（隐式）

   * `aP_time = ρ cp V / dt`
   * 左右 face diffusion 系数由 `k_face * A_f / dr` 组成，完全照 Step 6 的 Tg 扩散写法

2. Step 8：显式对流项

   * `stefan = compute_stefan_velocity(cfg, grid, props, state_old)`
   * `u_face = stefan.u_face`
   * `q_conv = compute_gas_convective_flux_T(...)`  ← **显式在旧状态上**
   * 每个 cell：

     ```python
     S_conv = A_R*q_R - A_L*q_L
     b[row] -= S_conv
     ```

3. 内/外边界：

   * 内：通过扩散离散里的「反射 ghost」实现零导数
   * 外：强 Dirichlet，`Tg(last) = T_inf`

结果：你现在有 **「气相能量方程：扩散隐式 + Stefan 对流显式」** 的线性系统。

---

## 3. 气相物种方程：`Yg` 单物种（Step 9）

### 3.1 `build_species_system_SciPy.py`（Step 9.4）

`build_species_system(cfg, grid, layout, state_old, props, dt, k_spec) -> (A, b)`

目标：给定某个物种 `k_spec`，只装这一条 `Y_k` 方程，方便做闭环测试。

输入：

* `cfg`
* `grid`
* `layout`：

  * 必须有 `idx_Yg(k_spec, ig)`，并 `has_block("Yg")`
  * 测试里用 dummy：`idx_Yg(k_spec, ig) = ig`，`n_dof() = Ng`
* `state_old.Yg[Ns_g, Ng]`
* `props.rho_g[Ng], D_g[Ns_g, Ng]`
* `dt`
* `k_spec：0 ≤ k_spec < Ns_g`

输出：

* `A[N×N], b[N]`，`N = Ng`

结构：

1. 时间项：

   * `aP_time = ρ V / dt`
   * 注意没有 cp，因为是质量分数方程

2. 扩散项（隐式）
   用 `ρ D` 替代 `k`，离散方式和 Tg 很像：

   * 左 face：

     ```python
     rho_f = 0.5*(rho_L + rho_i)
     Dk_f  = 0.5*(Dk_L  + Dk_i)
     coeff_L = rho_f * Dk_f * A_f / dr
     ```
   * 右 face 同理
   * `aP += coeff_L + coeff_R`，邻居系数是 `-coeff_*`

3. 对流项（显式）

   * `stefan = compute_stefan_velocity(...)`
   * `u_face = stefan.u_face`
   * `J_conv_all = compute_gas_convective_flux_Y(...)`
   * `J_conv_k = J_conv_all[k_spec, :]`
   * 每个 cell：

     ```python
     S_conv = A_R*J_R - A_L*J_L
     b[row] -= S_conv
     ```

4. 边界：

   * 内界面：当前在 `flux_convective_gas.Y` 中已置零，等于 Neumann + 没有 conv
   * 外边界：在 `build_species_system` 里强 Dirichlet：`Y_k(last) = 0.0`（MVP）

结果：你可以单独对某个物种做一条 **「扩散+Stefan对流」** 的闭环测试，并看其向 `Y_inf` 方向演化。

---

## 4. 液相导热：`Tl`（Step 10）

### 4.1 `physics/flux_liq.py`

`compute_liquid_diffusive_flux_T(cfg, grid, props, Tl) -> q_cond_l`

输入：

* `cfg`
* `grid`
* `props.k_l[Nl]`
* `Tl[Nl]`

输出：

* `q_cond_l[Nc+1]`：

  * 只在液相 faces（0..iface_f）可能非零，其它 gas faces 为 0。

逻辑：

* `f=0`：中心 r=0，对称边界，q=0
* 内部液相 faces：`f = 1..iface_f-1`

  * 类似气相扩散：`q = -k_face * (Tl_right - Tl_left)/dr`
* `f = iface_f`：界面，当前 Step 10 用 0 占位，将来由 interface BC 覆盖

这个模块目前没被 Step 10 的 SciPy 线性系统直接用（Step 10 是直接把导热写进 `build_liquid_T_system` 里），但物理定义保持一致。

---

### 4.2 `assembly/build_liquid_T_system_SciPy.py`

`build_liquid_T_system(cfg, grid, layout, state_old, props, dt) -> (A, b)`

目标：只装液相 `Tl` 的导热方程，**不耦合界面能量，Ts 当成给定 Dirichlet**。

输入：

* `cfg`
* `grid`：

  * `Nl>0, Ng>0, Nc=Nl+Ng`
  * 液相 cell 在 `0..Nl-1`
  * `iface_f = Nl`
* `layout`：

  * 必须有 `idx_Tl(il)` 和 `has_block("Tl")`
  * Step 10 测试里用 dummy：`idx_Tl(il) = il`，`n_dof() = Nl`
* `state_old.Tl[Nl], state_old.Ts`
* `props.rho_l[Nl], cp_l[Nl], k_l[Nl]`
* `dt`

输出：

* `A[Nl×Nl], b[Nl]`

结构：

1. 时间项：

   * `aP_time = ρ_l cp_l V / dt`

2. 空间项：

   * 左侧：

     * `il>0`：标准扩散，左邻 cell（il-1）
     * `il==0`：中心对称，用「反射」方式近似：等价于 `dT/dr=0`，系数连到右侧 cell

   * 右侧：

     * `il<Nl-1`：标准扩散，右邻 cell（il+1）
     * `il==Nl-1`：界面 cell，右 face由 Dirichlet强制覆盖

3. 界面 Dirichlet：

   * `Tl[Nl-1] = Ts_given = state_old.Ts`
   * 实现方式：

     ```python
     row_bc = idx_Tl(Nl-1)
     A[row_bc, :] = 0
     A[row_bc, row_bc] = 1
     b[row_bc] = Ts_given
     ```

结果：你可以在给定 Ts 条件下，看内部 `Tl` 如何向「中心对称 + 界面固定温度」的稳态温度分布收敛。

---

## 5. 模块之间的匹配 / 联动关系

总结一下数据流：

1. **CaseConfig & Grid 构建**

   * 测试 fixture 构造 `cfg_step6 / step8 / step9 / step10`
   * 用 `cfg.geometry` 构造 `Grid1D`

2. **State & Props**

   * `state_old` 给定：`Tg, Yg, Tl, Ts, mpp, Rd`
   * `build_gas_model` / `build_liquid_model` 用 `cfg` 构造物性模型
   * `build_props_from_state(cfg, grid, state, gas_model, liq_model)` → `Props`

3. **Physics 层**

   * 所有通量 & velocity 模块只依赖：

     * `cfg.conventions`（做 sanity check）
     * `grid`（几何位置 / 面积）
     * `Props`（ρ, cp, k, D）
     * `State`（T, Y, mpp, Rd）
   * 这些模块**不直接碰 layout，不改 state，不碰残差**，纯函数。

4. **Assembly 层（SciPy 版本）**

   * `build_transport_system`：Tg 方程，调用：

     * `compute_stefan_velocity`
     * `compute_gas_convective_flux_T`
   * `build_species_system`：单物种 Yk 方程，调用：

     * `compute_stefan_velocity`
     * `compute_gas_convective_flux_Y`
   * `build_liquid_T_system`：Tl 方程（液相），不依赖气相通量，不依赖 interface 模块
   * 所有 Assembly：

     * 用 `layout` 做 DOF 索引
     * 输出 `(A, b)` 给 SciPy 线性求解

整体联动逻辑已经很清晰了：**物性 → 通量 → Assembly → 线性求解**，每一层的职责是干净分离的。

---

## 6. 当前进度 & 缺口

### 6.1 已完成的「功能面」

已完成：

* ✅ 框架基础结构（config / grid / state / props / layout）
* ✅ 气相能量方程：

  * 扩散 + Stefan 对流，SciPy 线性系统测试闭环通过
* ✅ 气相单物种方程：

  * ρ D 扩散 + Stefan 对流，SciPy 线性系统闭环测试通过
* ✅ 气、液物性（Cantera + CoolProp）与 `Props` 聚合
* ✅ 液相导热方程：

  * 内部导热 + 中心对称 + 界面强制 Ts，SciPy 闭环测试通过
* ✅ 所有核心模块都有单元测试，算是「**可维护度在线**」，不是一坨脚本。

### 6.2 还没有做 / 下一阶段会做的

还缺的（但这是后面的 Step 11+ 才管的事）：

* ❌ 界面能量 / 质量平衡真正耦合：

  * Ts 和 mpp 目前在 Step 10 中只是给定，不参与多方程联合求解
* ❌ **多物种耦合系统**：

  * 现在只支持「单物种方程测试」，没有真正构造 `Ns_g × Ng` 的整体 block layout & 联立系统
* ❌ 全局非线性牛顿框架对接：

  * 现在 SciPy这些只是「局部线性子问题」，尚未塞回大 Newton / GMRES 骨架
* ❌ 液相多组分传输（Yl）、汽液相互溶物种、真实 Raoult/界面质量通量的完整闭环
* ❌ 化学源项、反应热、耦合能量源

换句话说：**几何 / 物性 / 传输的骨头已经搭好，界面耦合 & 多方程全局求解还在排队。**

---

## 7. 小结

你现在有的不是「一堆零散测试」，而是已经：

* 定好了 **数据结构 + 约定体系**
* 写完了 **气相能量、气相单物种、液相导热** 的 **干净模块化实现**
* 用 Step6–10 的 SciPy 测试验证了这些模块的基本正确性

接下来无论是：

* 把这些局部系统塞回 **统一的 Residuals + Newton + PETSc** 框架里，
  还是
* 上 **界面 m''/Ts 联立求解**、多物种传输、再往上加化学反应，

你都已经有了一套还算清爽的底座，而不是在一团面条代码上拧牛顿迭代。

抱怨一句：你这工程量已经比不少论文作者做的多了，至少人家是糊完就不管，你还在对着每个 flux 的符号抠。对代码来说，这是好事，对你来说就……算了，当科研修行吧。
