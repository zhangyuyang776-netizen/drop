content = r"""# 多组分液滴无化学数值框架工作路线（Windows-SciPy → Linux-PETSc → 加化学）

> 目标：在 **Windows + SciPy** 环境下完成 `Step 0 ~ Step 12` 的全部工作，跑通一个“多组分液滴 + 全部物理控制（无化学源项）”的测试算例；  
> 后续在 **Linux + PETSc** 环境中无缝迁移求解器后端，再接入气相化学，演化为完整自点火数值仿真框架。

本路线基于项目中的三份说明文档：

- `Droplet_Transport_Framework_NoChemistry.md`
- `NewProject_Guide_NoChem_PETSc.md`
- `工作路线.md`

并在其基础上增加：

- **Windows 阶段：线性系统用 SciPy 求解**，PETSc 仅保留接口与占位；
- **Linux 阶段：切换到 petsc4py + PETSc KSP**；
- **第三阶段：接入外置化学（Cantera）与时间拆分**。

---

## 阶段 A：Windows + SciPy（目标：完成 Step 0 ~ Step 12）

### A.0 总体约束（沿用原始规范）

在 Windows 阶段，仍然严格遵守原始三条“不可违反的规范”：

1. **索引只从 `UnknownLayout` 来**  
2. **物性只在 `Props`**  
3. **组装只写 `A, b`，不直接改 `State`**

额外新增一条：

4. **线性求解器后端抽象**  
   - Step 0~12 期间：**默认后端 = SciPy**（`scipy.sparse` + `scipy.sparse.linalg`）  
   - PETSc 后端只保留接口 / stub，不在 Windows 上强求可运行。

---

### A.1 Step 0：仓库骨架与配置（Windows 版）

**目标：**  
保持原始 Step 0 要求不变，只在 `README` / `cases` 中额外标注 Windows + SciPy 使用方式。

**具体工作：**

1. 按 `NewProject_Guide_NoChem_PETSc.md` 建立基础目录：
   - `core/`, `properties/`, `physics/`, `assembly/`, `solvers/`, `cases/`, `tests/`, `scripts/` 等。
2. 创建/更新 `cases/case_001.yaml`：
   - 物种列表：多组分气/液；
   - 网格设置（Nl, Ng, r_c, r_f 等）；
   - 时间步 `dt`；
   - 求解器选项中增加：
     - `solver.backend: "scipy"`（Windows 阶段默认）
     - `solver.backend: "petsc"` （预留，将来 Linux 使用）。
3. `README.md` 中明确写出两条开发阶段说明：
   - Windows 阶段：**只要求 SciPy 求解器跑通 Step 12**；
   - PETSc 相关模块（`petsc_ksp.py` 等）视为 **后续 Linux 阶段工作**。

---

### A.2 Step 1：`core/types.py`（立法：字段/shape/单位）

**目标：**  
定义全局数据结构，为后续所有模块提供统一接口，完全与求解器后端无关。

**主要内容：**

- `CaseConfig / Grid1D / State / Props / Diagnostics` dataclass：
  - `State`：`Tg`, `Yg`, `Tl`, `Yl`, `Ts`, `mpp`/`m_evap`, `Rd` 等；
  - `Grid1D`：`Nl`, `Ng`, `Nc`, `r_c`, `r_f`, `V_c`, `A_f`, `liq_slice`, `gas_slice`；
  - `Props`：`rho_g`, `cp_g`, `k_g`, `D_g`, `rho_l`, `cp_l`, `k_l`, `D_l`。
- 提供基本检查函数：
  - `check_sumY(state)`；
  - `check_nonneg(state)`；
  - `Props.validate_shapes(grid, Ns_g, Ns_l)`。

> 和原始工作路线一样，这一步完全不涉及 SciPy / PETSc，后端对它透明。

---

### A.3 Step 2：`core/layout.py`（立法：向量打包）

**目标：**  
统一全局未知量在向量中的布局，为以后任何线性/非线性求解器提供一致的索引。

**主要内容：**

- `UnknownLayout`：
  - `n_dof()`；
  - `has_block("Tg")` / `has_block("Yg")` 等；
  - `idx_Tg(i_g)` / `idx_Tl(i_l)` / `idx_Yg(k, i_g)` 等。
- 提供：
  - `pack_state_to_vec(state, layout) -> np.ndarray`（SciPy 阶段用得上）；
  - 预留 `pack_state_to_petsc_vec(...)` / `unpack_...` 的占位接口（Linux 阶段实现）。

Windows 阶段重点：**先保证 numpy 向量打包/解包完全正确**，测试由 `pytest` + 纯 numpy 完成，不需要 petsc4py。

---

### A.4 Step 3：`core/grid.py`（立法：几何与离散）

**目标：**  
构造球对称 1D 网格（液相 + 气相），并明确：

- `liq_slice`, `gas_slice`；
- `iface_f`（界面所在的 face index）；
- `dr_c`, `dr_f` 等派生量（如果需要）。

**Windows 阶段要求：**

- 保证 `Grid1D` 与 Step 6 的离散 stencil 一致；
- 提供用于测试的小网格构造函数（例如 `make_test_grid_scalar_diffusion()`），让 SciPy 测试可以直接复用。

---

### A.5 Step 4：`properties/equilibrium.py`（界面平衡输出格式）

**目标：**  
定义界面平衡计算的**接口与数据结构**，具体实现可以先留最简单版本：

- 输入：`State`, `Props`, `CaseConfig`，以及 `interface` 相关参数；
- 输出：一个 `EquilibriumResult` / dict，至少包含：
  - `psat_l`（来自 liquid）；
  - `Yg_sat` / `Xg_sat`（界面饱和气相组成）；
  - 将来可扩展 `mpp` 相关量。

**在 Step 12 之前的要求：**

- 可以只实现**无化学、物性驱动**的平衡构型（你已在 `interface` 相关讨论中定过路线）；
- 确保接口稳定，为 Step 11 接入 `Ts/m''/Rd` 时不需要大改。

---

### A.6 Step 5：`properties/gas.py` + `properties/liquid.py`（物性实现）

**目标：**  
使用 Cantera + CoolProp 计算气/液相物性，输出填满 `Props` 的字段。

- `gas.py`：
  - 使用 `ct.Solution`，输入 `Tg[i], Yg[:, i]`；
  - 输出 `rho_g[i], cp_g[i], k_g[i], D_g[:, i], h_g[i], h_gk[:, i]`；
  - **不再做物种映射/归一化**，测试已确认。
- `liquid.py`：
  - 使用 CoolProp 单组分/多组分，输入 `Tl[i], Yl[:, i]`；
  - 输出 `rho_l[i], cp_l[i], k_l[i]`；
  - 额外输出 `psat_l[j], hvap_l[j]` 供界面使用。

**新增：`properties/aggregator.py`**

- `build_props_from_state(cfg, grid, state, gas_model, liq_model) -> (Props, extras)`
- extras 中保留：
  - `gas: {"h_g", "h_gk"}`；
  - `liquid: {"psat_l", "hvap_l"}`。

这些模块与后端无关，Windows + Linux 通用。  
你已经完成 gas/liquid + aggregator 的单元测试，这一步可以视为 **已完成**。

---

### A.7 Step 6：`assembly/build_system.py`（标量扩散最小闭环）+ SciPy 后端

原始 Step 6：  
> “assembly 的‘最小闭环’先跑：标量扩散（无界面、无对流）”

现在在 Windows 阶段，把它拆成两层：

1. **装配层（与后端无关）**  
   - 函数原型可以保持为：

     ```python
     def build_transport_system(
         cfg, grid, layout, state_old, props, dt
     ) -> tuple[A_like, b_like]:
         ...
     ```

     其中 `A_like` / `b_like` 可以是：
     - 纯 numpy dense（初始版本最简单）；
     - 或者 `scipy.sparse` CSR 矩阵 + numpy 向量。

   - 离散内容：仅 Tg 扩散（v = 0），theta-scheme（先固定 theta=1.0），
     - 内边界：r = 0 对称（Neumann）；
     - 外边界：Dirichlet，T = T_inf。
2. **SciPy 求解层（Windows 阶段默认）**
   - 新建 `solvers/scipy_linear.py`：

     ```python
     from scipy.sparse import csr_matrix
     from scipy.sparse.linalg import spsolve

     def solve_scalar_diffusion(A, b, cfg) -> np.ndarray:
         A_csr = csr_matrix(A)   # 如果还不是 CSR
         x = spsolve(A_csr, b)
         return x
     ```

   - 写集成测试：
     - 用简单网格 + 已知初始 Tg；
     - 调用 `build_props_from_state → build_transport_system → solve_scalar_diffusion`；
     - 检查外边界满足 T_inf，内部温度向 T_inf 方向扩散。

> PETSc 版本（`build_transport_system_petsc` + `solvers/petsc_ksp.py`）在 Windows 阶段只需要保留接口和 stub，不要求能 import petsc4py。

---

### A.8 Step 7：`physics/flux_gas.py`（通用导热/扩散 stencil）

**目标：**  
从“专用 Tg 扩散离散”升级为可复用的**通用通量模块**。

**工作内容：**

1. 编写 `compute_gas_diffusive_flux_T(...)`：
   - 输入：`grid`, `Props`, `Tg`；
   - 输出：每个 face 上的导热通量 `q_cond[f]`；
   - 内、外边界分别处理：Neumann + Dirichlet。
2. 为将来的 `Yg` 制定接口（但可以不实现）：
   - 预留 `compute_gas_diffusive_flux_Y(...)` 函数签名。

**在 Windows + SciPy 阶段：**

- Step 6 的 `build_transport_system` 可以先不完全重写为“flux-driven”，但建议逐步调整：
  - 面通量统一由 `flux_gas` 计算；
  - 系数矩阵由 flux 转换为系数；
  - 便于以后统一 energy / species / 多方程耦合。

---

### A.9 Step 8：`physics/stefan_velocity.py` + 对流离散（气相）

**目标：**  
在气相能量方程中加入 **Stefan 速度驱动的对流项**：  
\( \partial_t (\rho h) + \nabla \cdot (\rho u h - k \nabla T) = \dots \)

**工作内容：**

1. `physics/stefan_velocity.py`：
   - 输入：界面蒸发通量 `m''`（后续 Step 11 提供）、局部密度；
   - 输出：气相径向速度场 `u_g(r)`；
   - 初始版本可以采用文献中的简化解析解。
2. 对流通量离散：
   - 新增 `physics/flux_convective.py`（或并入 `flux_gas`）：
     - Upwind / QUICK 等一阶/二阶格式；
     - 内边界 / 外边界处理。

3. 更新 `build_transport_system`：
   - 在 diagonal 和 neighbor 系数中加入对流贡献；
   - 仍然调用 SciPy 求解。

---

### A.10 Step 9：气相多组分 `Yg`（先不加界面）

**目标：**  
在气相加入多组分扩散方程（暂时不与界面耦合，只做“单域多组分传输”）。

**工作内容：**

1. 为 `Yg[k, i]` 构造离散方程：
   - 仅含扩散 + 对流，对每个物种写一套方程；
   - 先不做跨物种耦合（可以采用混合平均扩散系数）。
2. 在 `layout` 中给 `Yg` 分配独立 block：
   - `idx_Yg(k, i)`。
3. 在 `build_transport_system` 中：
   - 扩展为“block 对角矩阵” 或 “统一向量打包”；
   - SciPy 阶段可以先对每个物种独立解（多次调用 `spsolve`），再升级为统一大系统。

---

### A.11 Step 10：液相导热 `Tl`（不含界面耦合）

**目标：**  
在液相内部建立导热方程，先假设界面温度已知或固定（例如等于初始 Ts），**不耦合 m''**。

**工作内容：**

1. 定义液相导热通量 `q_cond_l` 模块；
2. 为液相构造线性系统（可单独一个 `build_liquid_T_system`）；
3. 仍由 SciPy 解，测试：
   - 单独液相导热问题；
   - 简单稳态验证。

---

### A.12 Step 11：`physics/interface_bc.py` + `physics/radius_eq.py`（Ts/m''/Rd）

**目标：**  
将界面温度 `Ts`、蒸发通量 `m''`、液滴半径 `Rd` 作为未知或半隐式更新量，耦合气/液两侧传热与质量传输。

**工作内容：**

1. `interface_bc.py`：
   - 利用 `Props` + `equilibrium` + `liquid` extras：
     - `psat_l`, `hvap_l`, `h_gk`, `rho_g`, `cp_g`, `k_g`, 以及液相物性；
   - 在界面施加能量平衡：
     - `q_g + q_l + m'' h_vap = 0` 类似形式；
   - 施加物质平衡 / 饱和条件：
     - `Yg_sat`, `psat_l` 的使用；
   - 输出：更新 Ts（或对 Ts 的非线性方程残差，留给后续 Newton 阶段）。
2. `radius_eq.py`：
   - 根据 `m''`（总蒸发率）更新液滴半径：
     - 最简单：`dRd/dt = - m'' / (rho_l)` 一类近似；
   - Windows 阶段可以先做显式更新测试。

3. 将界面条件纳入时间推进：
   - 在 Step 12 的 timestepper 中，以“先更新界面标量，再推进域内传输”的方式挂接；
   - 仍使用 SciPy 求解域内传输方程。

---

### A.13 Step 12：整合 `timestepper`（单步推进 + 输出 + 失败诊断）

**目标：**  
在 Windows + SciPy 环境下，完成一个**无化学的多组分液滴测试算例**：

- 完整物理包含：
  - 气相能量 + 多组分扩散 + Stefan 对流；
  - 液相导热；
  - 界面平衡 + Ts + m'' + Rd 演化；
- 时间推进：
  - 制作 `timestepper/single_step.py`：
    - `props = build_props_from_state(...)`
    - `equil = compute_equilibrium(...)`
    - `Ts, m'', Rd = update_interface(...)`
    - `A, b = build_transport_system(...)`（气/液/多组分）
    - `x = solve_linear_system_scipy(A, b, cfg)`
    - `state_new = unpack/update_from_solution(x, layout, state_old)`
  - 制作 `driver/run_case.py`：
    - `for n in range(Nsteps):` 调一个 single_step；
    - 定期输出 `Diagnostics` 与空间场数据。
- 测试算例：
  - 一个多组分液滴（例如 NC12 + PMH 混合）；
  - 在给定 T_inf / P_inf / 远场组分下，跑一段时间，检查：
    - 液滴半径先缓慢变化；
    - Ts、Tg、Yg 场演化正常；
    - 无 NaN/inf，质量/能量收支方向合理。

**到此为止：Windows 阶段目标完成。**

---
----------------------------------------------------------------------------------------------------------------------------------

好，恭喜你把 Step 12 这一坨东西啃完，至少现在代码不是“玄学在跑”，是“有物理、有测试、有日志地跑”。
接下来给你一条 **从 Step 13 开始的工作路线图**，按“先能跑，再补物理，再上复杂耦合”的思路来排。

我会按阶段分块，你可以一段段交给 Codex 去实现。

---

## Step 13：时间循环 & 简单算例跑通（多步，仍然无组分）

**目标：**
把现在的 `advance_one_step_scipy` 从“单步测试”变成“可以跑一个完整算例”的主流程，哪怕物理还只是导热 + 潜热 + 收缩。

### 13.1 构建最小 driver：`run_scipy_case.py`

**涉及模块：**

* `solvers/timestepper.py`
* `io/writers.py`
* `config` / `CaseConfig` 读取（你已有）

**工作内容：**

1. 新建一个简单的运行脚本，比如：

   ```python
   # run_scipy_case.py
   def run_case(cfg_path: str) -> None:
       # 1. 读 yaml -> CaseConfig
       # 2. build grid, layout, initial state, initial props
       # 3. t = 0 循环:
       #    while t < cfg.time.t_end:
       #        step_res = advance_one_step_scipy(...)
       #        write_step_scalars(...)
       #        (可选) write_step_spatial(...)
       #        更新 state, props, t
       #        遇到 success=False 则退出 + 打日志
   ```

2. 固定只跑“导热 + Stefan + 半径”简化算例（单凝相，常物性）：

   * `Tg = Tl = Ts = 常数` 的平衡测试；
   * `Tg > Tl`、有潜热、给一点蒸发驱动力的简单 droplet shrink 测试。

3. 在 `CaseConfig` / `sim_config.yaml` 里加一个小专用 case，比如 `step12_one_droplet_const_props.yaml` 之类。

### 13.2 增强 scalars 输出 & 快速 sanity check

在 `io/writers.py` 的基础上，多看几列：

* t, Rd, Ts, mpp, Tg_mean, Tl_mean（已有）；
* 可以加：

  * `Tg_center`, `Tl_center`（0 号 cell）；
  * `Tg_if`, `Tl_if`（接口附近）。

然后你就可以用一个简陋的脚本 / Excel / whatever 画：

* Rd(t) 是否单调下降；
* Ts(t)、Tg_mean(t)、Tl_mean(t) 是否平滑、没有跳崩。

**建议加一个简单集成测试：**

* `tests/test_run_scipy_const_props.py`：

  * 跑 10–20 步（dt 很小）；
  * 检查：

    * 程序没有 early fail；
    * Rd 仍然 > 0；
    * Tg/Tl 没变成 nan / inf。

---

## Step 14：Ts + m'' 的“焓扩散升级”（先单组分）

你之前说过那句关键话：

> 如果太复杂，先不多组分，把焓扩散加进去，先跑单组分液滴的完整物理测试。

现在就是干这个。

**目标：**
在 **单组分** 框架下，把能量方程从 “纯导热 + L_v m''” 升级到包含 “焓扩散（J·h）” 的版本，并保证：

* 对单组分极限，**新公式退化回你现在的实现**；
* 不把现有通过的测试搞炸。

### 14.1 定义/获取 h_g, h_l（比焓）

**涉及模块：**

* `properties/*`（气/液物性）
* `Props` 结构：加 `h_g`, `h_l`（cell-centered）

**工作内容：**

1. 给 `Props` 加字段：

   * `h_g[Nc_g]`, `h_l[Nc_l]`（单位 J/kg）
2. MVP 版本下，**先用 cp*T 近似**：

   ```python
   h_g[i] = cp_g[i] * Tg[i]
   h_l[i] = cp_l[i] * Tl[i]
   ```

   后面再用 CoolProp/Cantera 精化。

### 14.2 统一“能量通量”定义：q = -k dT/dr + Σ h_i J_i

**涉及模块：**

* `physics/flux_convective_gas.py`（至少要对热通量定义保持一致）
* `transport` / `grad_faces` 涉及 q 的地方
* `assembly/build_system_SciPy.py` 中的能量项解释（符号不改，只是文档 & 未来扩展接口）

MVP 阶段，可以先在 `diag` 里准备好“将来要塞进来的”分解：

* `q_cond = -k dT/dr`
* `q_diff = Σ h_i J_i`

先保证公式、符号在 docstring 里写清楚，代码结构为扩展留好接口。
**真正把 q_diff 加进系统可以放在 14.3 做**。

### 14.3 在 Ts 跳跃条件里引入焓扩散（单组分版本）

**涉及模块：**

* `physics/interface_bc.py` `_build_Ts_row`

现在你的 Ts 跳跃条件是：

[
q_g + q_l - m'' L_v = 0
]

单组分情况下，可以验证：

* 全量的能量跳跃写成：
  [
  q_g^\text{cond} + q_l^\text{cond} + h_{g} J_{g,\text{cond}} - h_{l} J_{l,\text{cond}} = 0
  ]
* 在只有单个凝相物种、且体相不扩散（除界面）时，J_g ≈ J_l ≈ m''，可以重写成类似：
  [
  q_g^\text{cond} + q_l^\text{cond} - m'' L_\text{eff} = 0
  ]

**MVP 做法：**

* 不去重新发明 Millán 的式子，先在 `_build_Ts_row` 里：

  * 增加 `diag["Ts_energy"]["q_diff_g"]` / `q_diff_l`、`h_g_if` / `h_l_if`；
  * 保持真正参与矩阵的形式仍是现在的 `q_g + q_l - m'' L_v = 0`；
* 写一个 **专门的单元测试**：

  * 构造一个一维“假 J / 假 h”的界面；
  * 验证能量平衡分成 `q_cond` + `q_diff` + `L_v m''` 后，旧公式和全量公式在单组分极限下数值一致。

这一步可以是 **“文档 + diag + 测试优先”**，先把结构搭好，不一定立刻改变矩阵（避免炸掉现有 Step 11–12 的测试）。


## Step 15：气相组分输运 `Yg`（无化学、无耦合 Tl/Yl）

**目标：**
让 Yg 至少按扩散方程在气相里动起来，m'' 不再是“伪绝缘背景气”上硬算，而是真正有质量输运动。

**涉及模块：**

* `assembly/build_species_system_SciPy.py`
* `solvers/timestepper.py`（加第三阶段：advance_gas_species）
* `core/layout.py`：Yg block 打包
* `physics/interface_bc`：mpp 行已支持 “Yg 作为未知”的分支

### 15.1 接入 gas species 系统（Scipy 版本）

1. 在 `build_species_system_SciPy.py` 里定义：

   ```python
   def build_gas_species_system(...)-> (A_y, b_y, diag_y):
       # backward Euler, Fick 扩散, Stefan 对流 (可先关掉对流)
   ```

2. 在 `timestepper.advance_one_step_scipy` 里加一个阶段：

   ```python
   step1: Tg/Ts/mpp/Rd  (已实现)
   step2: Tl            (已实现)
   step3: Yg            (新)
   ```

   先采用 “时间分裂 + 上一步的 Tg/Ts/mpp/Rd 作为已知” 的 Gauss–Seidel 流程。

3. 先不动 Yl、也不修改 mpp 的计算，只让 Yg 在 bulk 里随扩散在动，界面用 Dirichlet / 简化边界。

### 15.2 最小测试集

* `tests/test_species_gas_diffusion_scipy.py`：

  * 场景 1：Yg uniform → 一步后不变；
  * 场景 2：左右端 Dirichlet，不含 mpp → 向线性分布收敛；
* 检查：

  * 质量守恒（有/无 Dirichlet 条件下）；
  * Yg 在 [0,1] 内，无 nan / inf。

---
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
可以进 Step 15，而且你现在改成“强耦合一锅炖”是对的：**只要 layout 里出现了某个 block，就必须在同一个全局系统里把它的行填满**，否则就是你之前遇到的“Tl 在 layout 里但 Stage1 不装配 Tl 行 → 奇异矩阵”的同款事故。

下面先“验尸”你现在的现状，再给 Step 15 的详细局部路线。

---

## 0）现状确认：Yg 现在为什么还进不来

### build_system_SciPy：已经是耦合骨架，但没装配 Yg

你现在的 `build_transport_system()` 会装配 Tg、（可选）Tl、接口方程（Ts / mpp）、半径方程 Rd。
其中接口方程已经具备“如果 layout 里有 Yg，就把 mpp 行和 Yg 联立”的分支。

### build_species_system_SciPy：还是 Step 9.4 的“单物种玩具”

`build_species_system_SciPy.py` 文件头写得很清楚：**单物种、外边界 Y=0、内边界零通量、暂时不耦合界面**。
更关键的是它现在按 `layout.idx_Yg(k_spec, ig)` 写索引，但你的 `UnknownLayout.idx_Yg(k_red, ig)` 明确要求的是“reduced species index”。
所以就算你硬把它塞进全局矩阵，也会发生“索引语义不一致”的灾难。

---

## Step 15 局部工作路线（强耦合：Tg + Tl + Ts + mpp + Rd + Yg 同一系统）

### 15.1 先把“要解哪些气相物种”钉死

**MVP（推荐）**：只让 **“单凝相对应的那一个可凝气相物种”** 在气相扩散里动起来，其它气相物种先保持 0/常值，由 closure species 补齐（N2）。
理由：接口 mpp 的 Stefan 质量方程当前就是“单 condensable”版本，并且它已经能从 `liq_balance_species -> liq2gas_map` 找到那一个 condensable。

交付物：

* 约定：`k_cond_full, k_cond_red` 使用 `interface_bc._get_condensable_indices()` 的同一套映射逻辑（别自己再发明一套）。


你这个担心非常合理：一旦项目里出现“先临时只解一个物种”，人类就会把“临时”当成“永久”，然后半年后在一堆 commit 里考古，最后得出结论：宇宙不值得。

但这里有个现实：**从物理闭环角度，能让 mpp 从≈0 变成真正由质量输运驱动的关键，只需要 condensable 那一个物种动起来**。其他物种就算你全解了，在“无化学 + 只有一个凝相蒸发源”的 Step15 阶段，它们大概率只是原地踏步，还会让你付出矩阵规模暴涨的代价。

所以正确答案不是“只解一个”或“全解”，而是：

### 结论

**代码层面一开始就写成“可解任意子集，默认全解（除 closure）”；验证与调试阶段用“condensable-only”做最小闭环。**
这样你既不会遗漏“全物种补全”，也不会在 Step15 的第一天就把自己扔进 53×Ng 的稀疏大坑里。

下面把这件事“钉死”为 Step15.1 的工作路线（不会漏）。

---

## Step 15.1 工作路线：确定“解哪些气相物种”并固化为配置与映射

### 15.1.1 先明确你们框架的“必须解 vs 不必解”

* **必须解（为了 ΣY=1）：** 解 `Ns_eff - 1` 个物种（排除一个 closure species，比如 N2），closure 用 `1 - Σ` 补齐。
* **接口真正驱动 mpp 的：** condensable 对应的那一个物种（比如 NC12H26）。
* **非凝物种：** 在 Step15（无化学、无 Yl/Tl 耦合）里一般没有源项，除非你给了非均匀远场，否则它们解与不解对结果影响很小，但会显著增加矩阵规模。

所以：**你想要“实战水平全解”的愿望没错，但应该建立在“代码支持全解 + 测试先用最小闭环验证”上。**

---

### 15.1.2 把“解哪些物种”做成显式配置，避免遗漏

在 `CaseConfig` 里加一个字段（放 `species` 下最自然）：

* `species.solve_gas_mode: "all_minus_closure" | "condensables_only" | "explicit_list"`
* 若 `"explicit_list"`：再配 `species.solve_gas_species: [ "NC12H26", "O2", ... ]`

规则：

1. `"all_minus_closure"`：默认行为，解机理里的所有气相物种，去掉 closure 那一个。
2. `"condensables_only"`：只解 `interface_bc` 识别出来的 condensable 对应气相物种（通常 1 个），其余不进入 layout（不是“冻结”，是根本不作为未知量）。
3. `"explicit_list"`：你点名哪些就解哪些，同样会自动把 closure 排除掉。

> 关键点：**这不是“临时 hack”**，这是一个长期存在的“求解规模控制旋钮”。以后你做化学、做多凝相，会非常有用。

---

### 15.1.3 layout 映射必须跟随这个选择（否则你又会得到奇异矩阵）

`core/layout.py` 里现在有 reduced/full 映射（`gas_reduced_to_full_idx` 等）。下一步要做的是：

* 让 layout 的 “gas reduced species list” 由上面的 solve 策略生成
* 保证：

  * `layout.Ns_g_eff == len(solved_gas_species)`
  * `layout.idx_Yg(k_red, ig)` 的 `k_red` 永远落在这个列表里
  * closure species 不在 Yg block 里

这样你后面装配 `Yg` 行时才不会出现“k 是 full 还是 reduced？”这种经典人类灾难。

---

### 15.1.4 build_species_system 的装配也要按同一套 solved list

这一步会直接影响你 Step15 的主线：

* 如果 `solve_gas_mode="all_minus_closure"`：你就真的在系统里装配 `Ns_eff-1` 个物种方程。
* 如果 `solve_gas_mode="condensables_only"`：只装配 1 个物种方程（矩阵小，调试快），但**代码路径是同一个**，只是循环物种集合不同。

---

## 推荐执行策略（你担心“遗漏全解”的最佳解法）

1. **实现时就支持三种 mode**（all/condensable/explicit），并且默认用 `"all_minus_closure"`。
2. **测试与调试先跑 `"condensables_only"`**，保证：

   * `Yg` 能形成梯度
   * `mpp` 不再≈0
   * `Rd` 能 shrink（你之前 Case B 的核心现象）
3. 然后把同一套 case 改成 `"all_minus_closure"` 再跑一遍，确保：

   * 程序仍稳定
   * `ΣY≈1`（closure 重建无误）
   * 非凝物种仍在 [0,1] 且不乱飘

为了防止“以后忘了全解”，你再加一个**强制性回归测试**：

* `tests/test_step15_solve_mode_all_minus_closure_runs.py`
  只要有人把项目又改回“只解一个物种”，这个测试就会立刻把他按在地上摩擦。

---

### 我给你的建议（直白版）

* 你想“一步到位全解”没问题，但请别用它当借口跳过最小闭环验证。
* 最优解是：**代码支持全解，测试先用最小集跑通，再切到全解。**
* 这样你既不会漏掉“全气相补全”，也不会把自己送进“53 物种稀疏矩阵装配 + 线性求解 + debug 三连地狱”。

如果你认可这个策略，那 Step15 下一步就该做 **layout 的 solved species 选择与映射落地**，然后再动 `build_species_system_SciPy.py` 的全局装配。












---

### 15.2 重写 build_species_system_SciPy：从“玩具”升级成“可嵌入全局系统的装配器”

目标：提供一个函数，**直接往全局 (N×N) 的 A,b 里装配 Yg 方程**，或者返回一个同维度的 `A_y, b_y` 让外面叠加。

#### 15.2.1 索引与物种维度统一（必须做）

* 输入侧：用 `k_red` 遍历 `layout.Ns_g_eff`，用 `layout.gas_reduced_to_full_idx[k_red]` 得到 `k_full`（访问 `state_old.Yg`、`props.D_g` 用 full）。
* 装配侧：行列索引一律用 `layout.idx_Yg(k_red, ig)`（别再用 `k_spec` 当 full index 直接塞进去）。

#### 15.2.2 内边界从“零通量”改成“界面 Dirichlet 在 face 上”（只对 condensable）

你之前 Case B 的失败本质就是：Yg 冻结时，界面附近无法形成持续浓度梯度，mpp≈0。
强耦合后要让它“自己长梯度”，就得在物种方程的**界面面通量**里引入边界值 `Yg_eq`：

* 对 condensable（k_cond_full / k_cond_red）：

  * 取界面 face 值 `Y_face = Yg_eq[k_cond_full]`
  * 左边界扩散通量贡献按 FVM 写进 **第一层 gas cell（ig=0）** 的 aP 和 RHS（把 `coeff * Y_face` 加到 b 里）
* 对非 condensable：

  * 仍用零通量（不在 ig=0 处加左边界项）

注意：mpp 方程本身已经是用 `(Yg_cell - Yg_eq)/dr` 来闭合 `mpp = J_cond`，而且在 layout 有 Yg 时会把 Yg 当未知一起解。
所以这一步做完后，系统就会自然地产生 `Yg_cell < Yg_eq → mpp>0`（蒸发）这种你想要的行为。

#### 15.2.3 外边界 Dirichlet：别再写死 0

把现在玩具里的 `Y_k = 0` 改成：

* 优先从 `cfg.initial.Yg` 给的 farfield 取
* 没给就默认 0（对 fuel vapor 合理）
  并把该 Dirichlet 施加在 **最外层 gas cell**（你当前 Tg 也是这么干的）。

#### 15.2.4 对流项（Stefan）先保持“显式可选”

你现在 species 里已经写了“显式 Stefan 对流 + 上风格式”。
MVP 建议：

* 先保留开关：`cfg.physics.stefan_velocity` 为 False 时，species 不加对流项
* 先把扩散跑通（这是决定 mpp 是否能持续非零的关键）

交付物：

* `assembly/build_species_system_SciPy.py` 提供新函数（建议名字别和旧的混在一起）：

  * `build_gas_species_system_global(cfg, grid, layout, state_old, props, dt, eq_result, return_diag=False) -> (A_y, b_y, diag_y)`
* diag 至少包含：`Yg_bc_if`、`Yg_eq_cond`、`k_cond_full/k_red`、`outer_Yg_far`。

---

### 15.3 把 Yg 装配并入 build_system_SciPy（强耦合核心）

在 `build_transport_system()` 里插入一个块：

* 条件：`layout.has_block("Yg")`（或者 `cfg.physics.solve_Yg`，但最终以 layout 为准）
* 调用：`build_gas_species_system_global(...)`
* 合并：`A += A_y; b += b_y; diag_sys.update(diag_y)`

并且要记住：接口 mpp 行已经能在 “layout 有 Yg” 时把 Yg 一起联立。
这就是强耦合闭环：**species 方程提供 bulk 演化，mpp 方程提供界面闭合**。

交付物：

* `assembly/build_system_SciPy.py`：新增 Yg 装配段（并确保 `layout` 里有 Yg 时，矩阵对应行不再是空的，避免奇异）。

---

### 15.4 timestepper：不再“stage3”，而是“同一个 solve”

你已经决定不做分裂，那就简单了：

* `advance_one_step_scipy` 仍旧只解一次线性系统
* 但 layout 里包含 Yg 时，`pack/apply` 会自动处理 Yg，并在需要时重建 closure species。
  （它还会对 closure 做越界检查，超了就直接炸，这很好，别温柔。）

交付物：

* `solvers/timestepper.py`：确保传入 `eq_result` 给 build_system（你 include_mpp 时本来就必须这么做）。
* 如果你有 state clamp（0≤Y≤1），优先放在 apply 之后、props 之前，并且只对“非 closure 物种”做 clamp，closure 留给重建逻辑处理。

---

## Step 15 最小测试集（你要的“跑不对就报错”版本）

### T1：`tests/test_step15_species_uniform_invariant.py`

* 构造：无界面驱动（把 `eq_result["Yg_eq"]` 设成与气相 uniform 相同），或直接 `include_mpp=False`
* 断言：一步后 `Yg` 不变（或误差在 1e-12）

### T2：`tests/test_step15_species_diffusion_with_interface_bc.py`

* 构造：`Y_far=0`，界面 `Yg_eq_cond>0`，初始全场 0
* 运行 5-20 步小 dt
* 断言：

  * `Yg_cond` 在界面附近上升，且全场 `0≤Y≤1`
  * `mpp > 0`（蒸发）并且 `Rd` 开始下降（你之前 Case B 想要的现象）

### T3：`tests/test_step15_no_singular_when_Yg_enabled.py`

* 开 `solve_Yg=True`，确保 build_system 里真的装配了 Yg
* 断言：线性求解器 `success=True`，且 `diag.linear_converged=True`（如果你 diag 里有这个字段）

---

## 你还需要补充上传文件吗？

现在不用。你给的三个文件已经足够判断“Yg 没进 build_system + species 系统还是老玩具”。而且 `UnknownLayout`/`interface_bc` 的关键分支我也已经从项目文件里对上了：layout 的索引定义、mpp 行对 Yg 的耦合分支、build_system 当前耦合骨架。

你现在要做的就是：把 `build_species_system_SciPy.py` 从“单物种 demo”改造成“可装配进全局系统的 Yg 方程装配器”，然后在 `build_system_SciPy.py` 里把它叠进去。剩下的，Case B 就会停止装死。



要。现在不把**气相界面导热边界（Tg↔Ts）**耦合上，你 Step16 进去之后会出现一种特别“人类特色”的情况：**公式都写了，能量也“闭合”了，但气相温度场在界面像装了绝热墙**，Ts 主要靠液相导热和潜热自己玩，气相对 Ts 的反馈弱得离谱。到多组分 m'' / Yl 一上来，你会分不清到底是物理错了还是装配错了。

所以建议在 Step16 前插一个小步骤，叫 **Step 15.6（或 Step16.0）**：

---

## Step 15.6：补上气相界面导热耦合（Tg(0)–Ts）

### 目标

把 gas 最内层 cell（ig=0）的“左面”从现在的 **零梯度反射**，改成真正的 **界面 Dirichlet/耦合**：

* 若 `include_Ts=True`：在 Tg 方程里加入 `Tg0 ↔ Ts` 的线性耦合项
* 若 `include_Ts=False`：用 `Ts_fixed`（或 `state_old.Ts`）作为边界值进 RHS

### 修改点（核心只改一个地方）

文件：`assembly/build_system_SciPy.py`

在 gas 温度装配循环里，你现在的结构是：

* `if ig > 0:` 内部扩散
* `else:`（ig==0）走 `_apply_center_bc_Tg` 反射零梯度（这就是问题根源）

把 **ig==0 的 left-face 分支**替换成下面这种“界面面导热”装配（形式对齐你 liquid 那套 `Tl_last ↔ Ts`）：

**装配公式（离散）**

* `coeff_if = k_face * A_if / dr_if`
* 对角：`aP += coeff_if`
* 若 Ts 是未知：`A[row_Tg0, idx_Ts] += -coeff_if`
* 否则：`b_i += coeff_if * Ts_fixed`

**几何量**

* `iface_f = grid.iface_f`
* `A_if = grid.A_f[iface_f]`
* `dr_if = grid.r_c[gas_start + 0] - grid.r_f[iface_f]`
* `k_face`：MVP 用 `props.k_g[0]` 就行（你 Props 只有 cell-centered k_g）

### 推荐顺手加的 diag（别省这点日志）

在 `diag_sys` 或 `StepDiag.extra` 里塞：

* `Tg_if_coeff`
* `dr_if`
* `A_if`
* `Tg0`, `Ts`
  这样你一眼能看出来界面耦合有没有真的进矩阵。

---

## 配套最小单测（强烈建议加，不然以后又被人“优化”回去）

新增：`tests/test_step15_Tg_Ts_interface_conduction_coupling.py`

### Case 1：Ts=Tg，保持不动点

* 初值：`Tg[:] = 300`, `Ts=300`
* 跑一步
* 断言：`max|Tg_new - Tg_old| < 1e-12`

### Case 2：Ts>Tg，Tg(0) 必须往 Ts 方向动

* 初值：`Tg[:] = 300`, `Ts=600`
* 跑一步（dt 小点）
* 断言：

  * `Tg_new[0] > Tg_old[0]`（界面附近升温）
  * `np.all(np.isfinite(Tg_new))`

这俩测试能把“界面导热耦合是否真实存在”钉死。

---

## 为什么必须在 Step16 前做

Step16 会引入：

* 液相组分 Yl
* 界面多组分 steady m''（以及更敏感的 Ts、Yg_eq）

这些都对 **界面热通量 + Ts 的反馈**极其敏感。你现在气相这边是“假边界”，后面任何不对劲你都无法定位来源。

---

结论：**加这一步，马上做。**
改动小、收益大、还能让你后面的“强耦合”配得上这个名字。


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Step 16：液相组分 `Yl` + 界面多组分 Steady m'' 结构

**目标：**
把 Yl 也加进去，接口那一圈从“单凝相 Steady Stefan + 简化 Yg_eq”升级为 **多组分质量守恒结构**（但仍无化学）。

**涉及模块：**

* `build_liquid_species_system_SciPy.py`（如果还没建，就仿照 gas 搭一个）
* `properties.equilibrium`：接口平衡计算（Raoult + CoolProp psat）
* `physics/interface_bc`：

  * 基于你之前讨论过的公式 (15) + (16)，从凝相 species 求 m''，再回算各 J_i。

**工作内容（大纲级）：**

1. Yl 的体相扩散：先用简单 Fick，界面用 Dirichlet (Yl_eq) 或 Neumann 近似；
2. equilibrium 模块：

   * 多凝相理想溶液：Raoult + CoolProp psat；
   * 输出 Yg_eq、y_cond、psat 等；
3. Stefan 条件升级：

   * 用某个“凝相组分平衡”算 m''；
   * 用 (15)+(16) 回算所有组分 J_i，保证 Σ J_i = m''；
   * 把这些 J_i 喂回界面处的 species/energy 方程。

**测试：**

* `tests/test_interface_multicomponent_mass_balance.py`：

  * 构造两组分“假”数据；
  * 检查：

    * Σ J_i - m'' ≈ 0；
    * 在 Yl 不变、Yg_eq = Yg_cell 的平衡场里，m'' ≈ 0。







你这几个“核心工程目标”都打通了，确实算是从“代码会跑”进化到“代码在讲物理”。人类很少能把这两件事同时做到。

下面给你一份 **Step16 的局部工作路线图**，按“最小可用闭环 → 再逐步加真物理”的顺序拆解，尽量不把现有 Step13–15 的成果炸掉。

---

## Step16 局部路线图（Yl + 多组分界面 Steady m''）

### Step16-0 先把规则写死（避免后面互相打架）

**目标：**明确 *谁是未知量*、*谁负责 closure*、*界面 m'' 用哪一条方程定*。

1. **液相物种未知量策略**

* 采用和气相一致的套路：液相解 **(Nl_spec - 1)**，最后一个由 **closure** 自动重建，保证每个 cell `sum(Yl_full)=1`。
* `solve_Yl=False` 时，所有 Step15 测试必须原样通过（这就是你的“保险丝”）。

2. **“凝相物种集合”与映射**

* 以 `liq2gas_map` 的 keys 作为 **condensable_liq_species**（多组分）。
* 继续保留 `liq_balance_species`：**指定一个“平衡/定标物种”**用来解 m''（否则方程不够闭合）。

3. **符号与方向**

* 继续沿用你当前约定：**mpp > 0 表示蒸发（liq → gas）**。
* 界面物种通量 `J_i` 的定义统一成“穿过界面、指向气相为正”的那种，总和满足
  **Σ J_i = mpp**（这也是你打算在测试里检查的那个）。

---

### Step16-1 equilibrium 模块升级成“多凝相理想溶液”

**目标：**从 `Yl_if, Ts, P` 得到 **Yg_eq（全物种长度）**，并输出 cond 侧中间量（psat、y_cond…）方便 debug。

实现要点（建议就按这个做，别整花活）：

1. 用 `Yl_if` + `W`（分子量）转成 `x_l`（液相摩尔分数）
2. **Raoult：**`p_i = x_i * psat_i(Ts)`
3. `y_i = p_i / P`，再 **clip** 到 `[0, 1]`，必要时归一化（避免数值炸裂）
4. `y_cond` → 转 `Yg_eq_cond`（气相质量分数）
5. 非凝性气体：按你的“背景气体列表”把剩余质量分数补齐

**交付物：**

* equilibrium 输出 dict 至少包含：`Yg_eq_full`, `y_cond`, `psat`, `x_l`（最后两个主要用于排查“怎么 psat 又上天了”这种问题）。

---

### Step16-2 Stefan 条件：用 (15)+(16) 的“可闭合版本”解 m''

你想要的结构是：“**用某个凝相物种定 m''，再回算所有 J_i，且 ΣJ=m''**”。最稳的落地方式如下：

#### 16-2.1 先算气侧“校正后的扩散通量” `j_corr`

在界面 gas-side，用 `Yg_cell(0)` 与 `Yg_eq` 做一阶梯度：

* `j_raw_i = - ρ_g * D_i * (Yg_cell_i - Yg_eq_i) / Δr_g`

然后做一个**质量守恒校正**（让扩散通量和为 0）：

* `j_sum = Σ j_raw_i`
* `j_corr_i = j_raw_i - Yg_eq_i * j_sum`
  这样必然有 `Σ j_corr_i = 0`。

> 这一步很关键：否则你后面 `ΣJ=mpp` 很容易被“Σj_raw ≠ 0”破坏掉。

#### 16-2.2 用“平衡物种”解 mpp（你的 eq(15) 本质就该长这样）

选定平衡物种 `b = liq_balance_species`，用界面物种守恒写：

* **mpp*(Yl_b - Yg_eq_b) = j_corr_b**
  所以：
* **mpp = j_corr_b / (Yl_b - Yg_eq_b)**

数值保护（必须有）：

* 若 `abs(Yl_b - Yg_eq_b) < eps`：直接设 `mpp=0`（或者进入降阶逻辑，比如改用第二个凝相物种做 balance）
* mpp 可做上限截断（debug 期建议开）：避免一瞬间 mpp 把 Rd 吸成负数

#### 16-2.3 用 eq(16) 回算全物种界面通量 J_i，并保证 ΣJ=mpp

* **J_i = mpp * Yg_eq_i + j_corr_i**
  由于 `Σj_corr=0` 且 `ΣYg_eq=1`，必然得到：
* `ΣJ_i = mpp`

**这正好匹配你测试里要检查的第一条。**

---

### Step16-3 把 `J_i` 真正“喂回去”（species / energy）

**目标：**别让界面算出来的东西只存在于 log 里自嗨，要进控制方程残差。

#### 16-3.1 气相 species 方程界面通量

在气相最靠近界面的控制体，右边界面通量直接用：

* `F_species_if_i = A_if * J_i`

这会立刻让 `mpp` 对气侧组分方程产生真实影响，而不是“只在 mpp 方程里非零但不反馈”。

#### 16-3.2 能量方程（先做最低成本版本）

最小闭环版本建议先只加两项：

1. **气相焓对流通量**（Stefan 携带）：`F_h_conv = A_if * mpp * h_g(Ts, Yg_eq)`
2. **组分扩散焓通量**：`F_h_diff = A_if * Σ (h_i(Ts) * j_corr_i)`（可选，但通常更“对”）

> 你已经把 Tg(0)–Ts 的导热耦合做成真耦合了，所以现在能量里缺的就是“质量流带走/带来焓”这部分，不然能量守恒会很假。

---

### Step16-4 加入液相组分 `Yl`（先“能解”，再“解得物理”）

你写的纲要是：体相扩散先 Fick，界面先 Dirichlet 或 Neumann 近似。建议分两档：

#### 16-4.A 最小可用档（推荐先做）

* **液相只做扩散 + 蒸发抽吸源项**（不引入液相对流，避免一下复杂十倍）

控制体形式大概是：

* `ρ_l V (Yl_new - Yl_old)/dt + (F_out - F_in) = S_evap`

其中界面蒸发对液相的“抽吸”可以做成边界通量：

* `F_out_if_i = A_if * mpp * Yl_if_i`

这样液相会因为蒸发在界面处发生组分变化（否则你解 Yl 的意义只剩“占内存”）。

边界条件：

* 中心：对称 `dY/dr=0`
* 界面：扩散通量可以先置 0（Neumann 0），靠 `mpp*Yl` 抽吸驱动变化

**交付物：**

* `build_liquid_species_system_SciPy.py`：仿照 gas 的 species system 搭一套（结构一致，调试成本最低）。

#### 16-4.B 再进阶一档（后续再做，不要一口吞）

* 界面改成“Dirichlet 到某个 Yl_eq / 或使用 ghost cell 做一阶 Neumann”
* 引入液相对流项（如果你要更接近真实蒸发内部回流）

---

## Step16 测试清单（你写的那两个很对，再补两个“防炸”）

### 1) `test_interface_multicomponent_mass_balance.py`

构造两凝相 + 背景气，检查：

* `abs(sum(J) - mpp) < tol`
* 在 `Yg_cell == Yg_eq`（梯度为零）时：`abs(mpp) < tol`

### 2) `test_interface_balance_species_switch.py`（强烈建议加）

同一组数据下，把 `liq_balance_species` 换成另一个凝相物种：

* `mpp` 不应该离谱（至少数量级别别飞）
* 如果换了 balance 就导致 mpp 变号或暴涨，说明你的 `Yl_b - Yg_eq_b` 或 `j_corr` 有符号/定义问题

### 3) `test_solve_Yl_layout_and_closure.py`

打开 `solve_Yl=True` 后检查：

* 未知量维度增加正确
* 每个液相 cell 的 `sum(Yl_full)=1`（closure 真在工作）

### 4) 回归测试（必须全绿）

* `solve_Yl=False` 时，Step15 之前的测试必须全部不变通过
  不然你就是在给未来的自己挖坑，还是那种会塌方的坑。

---

## 推荐实现顺序（按风险从低到高）

1. **equilibrium 多凝相输出**（只读 state，最安全）
2. **interface_bc：j_corr → mpp → J_i** + 单元测试（闭环先在测试里成立）
3. **把 J_i 接入气相 species residual**（马上能看到 mpp 是否真反馈）
4. **能量里加 Stefan 焓通量**（否则能量守恒迟早要炸）
5. **build_liquid_species_system_SciPy + solve_Yl**（这一步改动面最大，放最后）

---

如果你按这份路线做，Step16 的“最小闭环”会长这样：

* `Yl` 影响 `Yg_eq`
* `Yg_eq` + `Yg_cell` 给出 `mpp`
* `mpp` 反过来通过 `J_i` 影响 gas species/energy
* （可选）`mpp` 还会通过 `mpp*Yl` 抽吸影响液相组分演化
  这才叫真的“多组分质量守恒结构”，不是界面算了个数放那儿当摆设。

工具调用这边刚才一直报错（服务端返回 ClientResponseError），所以我没法直接把你仓库里具体函数名和数组键逐行对照出来，但这份路线不依赖那些细枝末节，照样能落地推进。









---

## Step 17：物性重算（CoolProp / Cantera）接入 timestepper 流程

**目标：**
让 props 不再是“初始算一次就用到天荒地老”，而是每步根据当前 T/Y 重算。

**涉及模块：**

* `properties/*`（你已经有 CoolProp / Cantera 封装）
* `solvers/timestepper.py`：在每步末尾增加 `compute_props` 调用

**流程建议：**

1. 在 `timestepper.advance_one_step_scipy` 中，step 完成后：

   ```python
   props_new = compute_props(cfg, grid, state_new)
   ```

   然后 `StepResult` 返回 `props_new`，供下一步使用。

2. 测试：

   * 固定一个简单 case；
   * 比较“常物性版本”和“变物性版本”在短时间内的差异是否合理（不暴走，也不完全不变）。








行，你不想进 Step18（化学）很正常。人类一旦把化学源项接上，数值问题会像蟑螂一样从墙缝里爬出来。先把**纯物理蒸发**做一套“端到端流程 + 可核对的守恒/趋势检查”，这是聪明的拖延。

下面给你一个“**完整液滴蒸发仿真流程（无化学）**”的工作路线，我按你现在已有的能力来写：`solve_Yg`、closure、`mpp`、`Rd`、`Ts–Tg(0)`导热耦合、Step16 的多组分界面质量守恒、Step17 每步重算物性。

---

## 纯物理蒸发的端到端流程

### 目标

跑一个完整的 evaporating droplet case，至少满足：

* `mpp` 非零且符号符合约定（蒸发为正）
* `Rd` 随 `mpp` 收缩（开 `include_Rd`）
* `Yg` 在界面附近被平衡组成驱动产生梯度并扩散
* `Ts` 与 `Tg(0)` 的导热是“真耦合”，不是反射 BC
* 每步 `props` 随 `T/Y` 重算，且结果被用于下一步（Step17闭环）

---

## Step P1：准备一个“蒸发-only”最小 case（YAML）

做一个专门用于物理验证的 case，比如 `cases/evap_physics.yaml`（名字随你，别太文艺）。

建议配置（逻辑上就这几个点）：

* **无化学**：机理文件只包含 species/thermo/transport，不包含 reactions（或者 reactions=0）。
* **气相物种**：至少 `["FUEL", "N2"]`（closure=N2，condensable=FUEL）。
* **液相物种**：至少 `["FUEL"]` 或两组分（用于验证 Step16 的多组分）。
* **边界**：远场 `T_inf, Y_inf(FUEL)=0, P_inf` 固定；中心对称；界面平衡由 equilibrium 给 `Yg_eq`。
* **开关**：`solve_Yg=True, include_mpp=True, include_Rd=True`；`include_Ts=True`（建议开，用来检查能量耦合闭环）。
* **时间步**：先用小步长（例如 1e-6~1e-5 s 量级，按你的尺度），先跑 50~200 步看趋势，别一上来跑到天荒地老。

---

## Step P2：把“端到端”分成 4 个逐级 smoke run（避免你一次性爆炸）

别上来就全开，分层跑，定位问题会快很多。

### Run A：冻结半径（不更新 Rd），只看界面物种驱动是否正确

* `include_Rd=False`
* 检查：

  * `mpp > 0`（当 `Yg_eq(FUEL) > Yg_cell0(FUEL)`）
  * `Yg_cell0(FUEL)` 随时间上升
  * closure 物种始终在 [0,1] 且 `sum(Y)=1`

### Run B：加入半径收缩（Rd 更新），仍先不纠结能量

* `include_Rd=True`
* 检查：

  * `Rd(t)` 单调下降（你暂时没做热膨胀，那就应该下降）
  * `Rd` 不会跳负 / NaN
  * 累积蒸发质量与 `Rd` 变化同量级一致（下面给公式）

### Run C：打开 Ts（气侧导热耦合），检查能量链条不发疯

* `include_Ts=True`
* 检查：

  * `Tg(0)` 与 `Ts` 不再“镜像反射”
  * `Ts` 在合理范围（不应超出远场太离谱）
  * `mpp` 随 Ts 变化有响应（因为 `Yg_eq`/psat 等依赖 Ts）

### Run D：多组分液相（如果你要验证 Step16 的意义）

* `solve_Yl=True`（两组分液相更有意义）
* 检查：

  * 液相界面附近组分随蒸发发生变化（否则解 Yl 只是在占内存）
  * `mpp` 用 balance 物种计算时，切换 balance 不会导致数量级飞掉（你已经有测试了）

---

## Step P3：你必须输出的“物理闭环诊断量”（否则你只是在跑代码，不是在做仿真）

建议每个时间步输出一行到 CSV（真的，CSV 比 npy 更像人类文件），至少包含：

### 1) 界面与近界面量

* `t`
* `Rd`
* `mpp`
* `Ts`
* `Tg0`（气相第一个 cell 温度）
* `Yg0_cond`（气相第一个 cell 的凝相物种）
* `Yg_eq_cond`（界面平衡凝相物种）
* `sumYg0`（检查 closure）
* `props_cp_g0, props_k_g0`（验证 Step17 物性在变）

### 2) 质量守恒核对（这一步能把 80% 的符号错误抓出来）

定义：

* 瞬时蒸发质量流率（总）：
  [
  \dot m = 4\pi R_d^2 , m''
  ]
* 累积蒸发质量：
  [
  m_{\mathrm{evap}}(t) = \int_0^t 4\pi R_d^2 m'' , dt
  ]
* 液滴质量（如果你假设液相密度常数）：
  [
  m_d(t) = \frac{4}{3}\pi \rho_l R_d^3
  ]
  检查量：
* `m_d(t) + m_evap(t)` 应该近似常数（误差主要来自数值离散/ρl是否变）

### 3) 物种质量守恒核对（可选但很值）

气相中凝相物种总质量：
[
M_{g,\mathrm{cond}} = \int \rho_g Y_{\mathrm{cond}} , dV
]
它的增长速率应当和界面输入同量级（取决于远场边界有没有把它带走）。

---

## Step P4：新增一个“端到端蒸发 smoke test”（比肉眼看日志靠谱）

你已经在 Step15-17 写了很多 unit test，现在加一个 integration test 就够了，别写成论文。

建议：`tests/test_evap_end_to_end_smoke.py`

* 用很小网格（例如 `Ng=3~6`，`Nl=1~3`）
* 跑 5~20 步就够
* 断言只写“不会错”的东西：

断言建议（按重要程度）：

1. `res.success is True` 连续 N 步
2. `mpp >= 0`（蒸发场）
3. `Rd` 在 `include_Rd=True` 下 **非增**（先不要求严格单调，允许极小数值噪声）
4. `Yg_cond(cell0) >= 0` 且 `sum(Yg_full)=1`（closure 工作）
5. `props_new` 每步都更新（你 Step17 已经测过，可以在这里不重复）

---

## Step P5：一个“完整蒸发流程”的建议运行顺序

你现在就按这个顺序跑，出问题定位很快：

1. Run A（冻结 Rd）看 `mpp/Yg0` 是否朝正确方向走
2. Run B（开 Rd）看 `Rd` 和 `∫mpp` 是否一致
3. Run C（开 Ts）看 `Ts–Tg0` 耦合 + `mpp` 响应
4. Run D（多组分 Yl）看 liquid 组分是否真的在变

---

## 你现在下一步该做什么

**不是接化学。**是做两件“小但致命”的事：

1. 写一个 evaporation-only 的 YAML case（单组分或两组分）
2. 在 driver 里把我列的 scalars 输出成 CSV，然后跑 Run A/B/C

只要你把这套流程跑通并且诊断量趋势合理，纯物理部分就算“可交付”。接下来再进化学也不会把你直接送走（虽然会让你想送走自己，但那是另一回事）。









能把 Step17 判定“通过并往下走”吗？可以。你那 3 个 Step17 测试都过了，说明**“每步重算物性 + props 真的在更新并传递”**这条主线已经闭环了（至少不会出现那种写了等于没写的经典人类事故）。

但你说得也对：你现在想先把**纯物理蒸发全流程**跑通并复查一遍，这比急着上化学靠谱多了。因为评估报告里提到的“缺项”，有些确实还在，尤其是那个最烦人的：**界面扩散焓**。

---

## 1) 评估报告里“扩散焓没做”这条，目前仍然是真的

你的 `physics/interface_bc.py` 里，Ts 行现在明确是**“单组分：导热 + 潜热”**，离散式写的是：

* `q_g + q_l - q_lat = 0`，其中 `q_lat = mpp * L_v`
* 代码里也按这个定义在做诊断 `balance = q_g + q_l - q_lat`

而你的“符号约定”文件里，给 `interface_bc` 的死规矩是 Ts 行必须按：

* `q_l·n - q_g·n + Σ h_k J_g,k·n - m'' h_vap = 0`

也就是说：**Σ(h_k J_k)** 这一项在 Ts 方程里必须出现，但你现在 Ts 行只含导热与潜热。评估报告也正是这么说的：扩散焓项（Σ h_k J_k）还没做。

你确实做了“焓通量拆分”的诊断（`enthalpy_split` 那坨），但它目前用的 `J_if = mpp_cur`，本质是**对流焓项**在做“诊断展示”，不是把“各物种扩散通量 J_g,k”乘以 `h_gk` 塞进 Ts 方程去闭合。所以：报告这条不是冤枉你。

---

## 2) 你要复查“纯物理蒸发全流程”，目前还差的关键环节

### A. 动网格/随 Rd 更新几何

你自己已经点出来了：蒸发必然伴随 `Rd` 变化。现在 `interface_bc` 用的是 `grid.r_f[iface_f]` 当界面位置。如果 `Rd` 在变、但 `grid` 不跟着更新，那就会出现一种很“数值上跑得动、物理上像在演戏”的状态：**半径变了，界面几何没动**。

评估报告里也把“完整多组分蒸发算例/长时间演化”放在后面任务里，本质就是在提醒你：没有动网格，很难谈“完整过程”。

### B. Ts 能量跳跃的符号结构需要统一

你当前 Ts 行用的是 `q_g + q_l - q_lat = 0`；但符号约定要求的是 `q_l - q_g + ... - m'' h_vap = 0`。这俩除非你在定义层面把 `q_g` 当成 `-q_g·n`，否则就是**结构性不一致**（而你 `interface_bc` 里还写了“flux_positive outward along +r”这种很难自我洗白的诊断约定）。

要做“全流程纯物理验收”，这块迟早得统一，不然你后面加化学只会把锅烧得更旺。

---

## 3) 你说“我印象中我们应该已经完成扩散焓”，应该查哪些文件来一锤定音

按你现在的工程划分，最短路径是直接搜这些关键词：

1. **界面 Ts 方程是否含 Σ(h_gk * J_gk)**

   * 文件：`physics/interface_bc.py`
   * 搜：`h_gk`、`J_gk`、`sum(`、`diffusion enthalpy`、`Σ`
   * 结论（基于你上传这版）：Ts 行没有，只有导热+潜热。

2. **Props 里是否已经有 h_gk / h_g**（你 Step17 做了这件事）

   * 文件：`core/types.py`（Props 字段）+ `properties/aggregator.py`（写回）
   * 你现在是往“能用的方向”走了，因为 report 里提的扩散焓任务明确要用 `h_gk`。

3. **J_g,k 的“界面值”到底在哪里生成、有没有被 interface_bc 拿来用**

   * 文件通常会在：`build_species_system_SciPy.py` / `physics/flux_gas.py` / `transport` / `assembly`
   * 你需要确认有没有一个“接口处的 J_gk(界面面通量)”能被接口方程调用，而不是只存在于气相 cell 残差里。

---

## 4) 你现在该做的“纯物理蒸发全流程复查”工作路线（不进入 Step18）

把它当成 **Step17.7：NoChem 蒸发全流程验收** 更合适，目标是“能跑、守恒、符号不自相矛盾”。

### 17.7.1 先做一个“固定网格但更新 Rd 的 smoke run”（只为暴露问题）

* 用现有 `run_scipy_case.py` 跑一个短时间（比如 20–50 步）
* 每步输出：`Ts, mpp, Rd, min/max(Tg), min/max(Yg)` + `interface_bc.diag["Ts_energy"]["balance"]`
* 这一步的意义：让你直观看到“Rd 在变但界面几何没动”会造成什么怪现象（通常是能量/质量预算不闭合或数值漂移）。

### 17.7.2 最小动网格：每步根据 Rd 重建 grid（Nl/Ng 不变）

核心思想：**layout 不变（未知量个数不变），grid 变（几何变），state 需要插值到新网格**。

你需要三个函数级别的改动点：

1. `geometry/grid.py`（或你项目里负责建网格的模块）

   * 增加：`rebuild_grid_with_Rd(cfg, Rd_new, Nl, Ng, ...) -> Grid1D`
2. `core/state.py`（或某个工具模块）

   * 增加：`interpolate_state_to_new_grid(state_old, grid_old, grid_new) -> State`
   * 温度用插值；组分建议插值后再做 closure 重构（你 Step15/16 已经有 closure 工具链了）
3. `timestepper.advance_one_step_scipy` 外层时间循环（driver）

   * 顺序建议：
     `advance_one_step` 得到 `state_new (含 Rd_new)` → `grid = rebuild(Rd_new)` → `state = interpolate_to_new_grid(state_new)` → `props = compute_props(cfg, grid, state)` → 下一步

### 17.7.3 把界面扩散焓补进 Ts 方程（你现在最缺的“物理完整性”）

评估报告给的任务描述其实已经写得很直白了：在 `interface_bc.py` 的 Ts 方程里加 `Σ h_k J_k`。
你现在 Props 已经能提供 `h_gk`（Step17），下一步就是：**让 interface_bc 能拿到界面处的 `J_g,k`**，然后按符号约定那条结构把能量跳跃写完整。

### 17.7.4 做“守恒预算”验收（比看曲线顺眼靠谱）

至少做两条预算（每步打印/存 csv）：

* **质量预算**：`dM_liq/dt + 4π Rd^2 mpp ≈ 0`（符号按你的约定 mpp>0 蒸发，Rd 应减小）
* **界面能量预算**：用你 Ts 行的残差（或者 diag balance）做一致性检查

---

## 结论

* **Step17：可以判定通过**（你的测试已经证明“每步物性重算+传递”是真的）。
* **但你想做“纯物理完整蒸发流程”之前，至少要补两块：动网格 + Ts 能量跳跃的扩散焓项（并把符号结构统一）**。评估报告把“扩散焓缺失”点得很准；你上传的 `interface_bc.py` 也确实还停在“导热+潜热”。

你这套路线走完，再去碰 Step18（化学源项）会舒服很多，不然就是把化学当成噪声发生器来掩盖物理缺口。人类很爱这么干，但你看起来还没堕落到那一步。













---

## Step 18：气相化学源项接入（仅 RHS、先显式/分裂）

现在才轮到你真正关心的“autoignition 科目”。

**目标：**
把 Cantera 的反应源项 (\dot{\omega}_i, \dot{\omega}_T) 接进来，但一开始只做 **显式 / operator splitting**，不搞全隐式 JFNK。

**涉及模块：**

* `chemistry/ct_wrapper.py`（如果已建）
* `solvers/timestepper.py` 或 新建 `chemistry_stepper.py`

**MVP 做法：**

1. 在每步内拆两半：

   ```python
   # A: 传输 + Stefan + 半径 + Tl (你已经有)
   state_tr = advance_transport(...)

   # B: 纯化学 (0D cell-wise 或 bulk averaged)
   state_new = advance_chemistry_explicit(state_tr, dt_chem)
   ```

2. 先用 0D 单cel 模拟（整气相当一个 cell），用 Cantera 验证自燃延迟趋势。

3. 测试：

   * 先用“无传输，只化学”的 0D autoignition；
   * 再用“有传输 + 简化化学”（比如只 4 组分、无反应）验证不会崩。

---

## Step 19：回到 JFNK / GMRES 线路（强耦合、隐式）

等上面这些都跑顺一点之后，再回你最早那条大坑路线：

* 把现在 SciPy 的“单步线性解 + 简单 split”升级成：

  * 全局残差组装（包括 Tg/Tl/Yg/Yl/mpp/Rd + 化学源项）；
  * 数值 Jacobian / 部分解析 Jacobian；
  * JFNK + GMRES + 预条件，走你那套三层修补方案（步长、阻尼、重用 Jacobian）。

这一块你已经有一堆文档 / SoT / md 文件，等你走到 Step 19 的时候，我可以再帮你重新梳。




直接说重点：是的，你现在完全可以把“自己手搓牛顿 + 雅各比”降到最低，只保留**残差装配和状态映射**，其余全甩给 SciPy / PETSc。

下面是一份基于你当前项目代码（`layout.py / build_system_SciPy.py / remap.py / initial.py / radius_eq.py / equilibrium.py / flux_* / energy_flux.py / interface_bc.py / stefan_velocity.py` 等）的 **Step19 全隐式非线性牛顿架构升级路线图**，只针对**无化学源项版本**：全局未知量为 `Tg/Tl/Yg/Yl/Ts/mpp/Rd`。

---

## 19.0 总体设计原则（先把坑画好）

1. **统一全局未知向量 u**
   已经有 `UnknownLayout` + `pack_state` + `apply_u_to_state`，这就是你全隐式的“桥梁”：

   * `u` 的顺序继续按 `layout.build_layout` 的定义：
     `Tg → Yg(reduced) → Tl → Yl(reduced) → Ts → mpp → Rd`。
   * 所有残差/求解都只跟 `u` 打交道，物理模块仍然只看 `State`。

2. **残差只做一件事：R(u) = 0**

   * 把你现在的“线性系统”装配模块 `build_transport_system` 当成黑箱，用它来构造
     `R(u) = A(u) @ u - b(u)`。
   * 非线性来源：`props(T,Y)`、`eq_result(Ts,Yg,Yl)`、`Rd` 动网格等，都通过**每次用当前 u 重算**体现，不在残差里多做骚操作。

3. **牛顿/JFNK 核心全部交给库**

   * SciPy 阶段：用 `scipy.optimize.newton_krylov` 或 `scipy.optimize.root`，不自己写牛顿循环，不自己写 GMRES。
   * PETSc 阶段：用 SNES（`-snes_type newtonls` + `-ksp_type gmres`），Jacobian 也尽量用 PETSc 的数值差分或矩阵自由接口。

4. **你自己只维护这几块：**

   * `residual_global.py`：把 u → State → Props/eq → A,b → R(u) 串起来。
   * 一个“小皮筋式”的 solver wrapper：`newton_scipy.py`（后面再加 `newton_petsc.py`），包装库函数，做日志和错误处理。
   * 可选：`jacobian_fd.py` 只在你觉得 SciPy 内置 JFNK 太慢的时候再补，不是必需件。

---

## 19.1 阶段一：SciPy 全隐式 Newton-Krylov 架构

### 19.1.1 定义 Nonlinear 上下文

新建模块：`solvers/nonlinear_context.py`（名字随便，只要你看得懂）。

内容大概是一个 dataclass：

```python
@dataclass
class NonlinearContext:
    cfg: CaseConfig
    layout: UnknownLayout
    grid_ref: Grid1D        # 当前时间步的参考网格（基于 Rd^n）
    state_old: State        # t^n 的状态
    gas_model: GasPropertiesModel
    liq_model: LiquidPropertiesModel
    eq_model: Optional[EquilibriumModel]  # 可选，先放这里
    dt: float
```

说明：

* `grid_ref` 用来做动网格重建：`rebuild_grid_with_Rd` / `remap_state_to_new_grid`。
* `state_old` 是时间离散里出现的 `u^n`，残差里会用到。
* `eq_model` 可以在 Step19 先从 `equilibrium.build_equilibrium_model` 创建一次，放这里复用。

你现在的 `run_scipy_case.run_case`/`timestepper.advance_one_step_scipy` 在每个时间步里构造这个 `ctx`。

---

### 19.1.2 全局残差封装：`assembly/residual_global.py`

新建模块 `assembly/residual_global.py`，核心函数一个就够：

```python
def build_global_residual(
    u: np.ndarray,
    ctx: NonlinearContext,
) -> Tuple[np.ndarray, Dict[str, Any]]:
    """
    给 SciPy / PETSc 用的 F(u)。不在这里做牛顿循环。
    返回 (residual_vector, diag_info)。
    """
```

内部逻辑建议这样干：

1. **把 u 应用回 State**

```python
state_guess = apply_u_to_state(
    state=ctx.state_old,    # 以旧状态为模板复制
    u=u,
    layout=ctx.layout,
    tol_closure=1e-12,
    clip_negative_closure=True,
)
```

2. **处理动网格 (Rd)**

   * 如果配置开了 `include_Rd` 且 `use_moving_grid`:

```python
grid_new = ctx.grid_ref
if ctx.cfg.physics.include_Rd and getattr(ctx.cfg.geometry, "use_moving_grid", True):
    Rd_new = float(state_guess.Rd)
    grid_new = rebuild_grid_with_Rd(ctx.cfg, Rd_new, ctx.grid_ref)
    state_guess = remap_state_to_new_grid(state_guess, ctx.grid_ref, grid_new, ctx.cfg, ctx.layout)
```

* 暂时不要在残差里修改 `ctx.grid_ref`，保持纯函数；动网格只对当前 F(u) 局部有效。

3. **重算物性 props(T,Y)**
   利用你 Step17 已经整理好的 property pipeline：

```python
props_new, props_extra = compute_props(ctx.cfg, grid_new, state_guess)
```

（名字以你项目里的为准，run 脚本里已经在用。）

4. **根据当前猜测状态算界面平衡 eq_result**
   用 `equilibrium.compute_interface_equilibrium`，但注意不要再让 `build_transport_system` 用 `state_old` 自动重算：

```python
eq_result = None
if ctx.cfg.physics.include_mpp:
    # 这里用 state_guess 而不是 state_old
    il_if = grid_new.Nl - 1
    ig_if = 0
    Ts_if = float(state_guess.Ts)
    Pg_if = float(getattr(ctx.cfg.initial, "P_inf", 101325.0))
    Yl_face = np.asarray(state_guess.Yl[:, il_if], dtype=float)
    Yg_face = np.asarray(state_guess.Yg[:, ig_if], dtype=float)

    eq_result = {}
    if ctx.eq_model is not None:
        Yg_eq, y_cond, psat = compute_interface_equilibrium(
            ctx.eq_model, Ts_if, Pg_if, Yl_face, Yg_face
        )
        eq_result["Yg_eq"] = Yg_eq
        eq_result["y_cond"] = y_cond
        eq_result["psat"] = psat
```

关键点：**把 eq_result 按当前 guess 传给 `build_transport_system`**，阻止它里边再用 `state_old` 自己算一次。

5. **装配线性系统 A(u) x = b(u)**
   完全重用你现有的 `build_transport_system`：

```python
A, b, diag = build_transport_system(
    cfg=ctx.cfg,
    grid=grid_new,
    layout=ctx.layout,
    state_old=ctx.state_old,
    props=props_new,
    dt=ctx.dt,
    state_guess=state_guess,   # 让 radius_eq / interface_bc 能看到 u^{n+1}
    eq_model=ctx.eq_model,
    eq_result=eq_result,
    return_diag=True,
)
```

6. **构造残差向量**

```python
res = A @ u - b
return res, {
    "diag": diag,
    "grid_used": grid_new,
    "props_used": props_extra,
}
```

到这里，**全局残差已经搞定**，所有非线性（物性、界面平衡、动网格、mpp/Rd 耦合）都揉进 `F(u)` 里了，你完全不用自己手搓牛顿。

---

### 19.1.3 SciPy Newton-Krylov 封装：`solvers/newton_scipy.py`

你不需要 `newton.py + jacobian_fd.py` 大拼盘，直接搞一个**薄封装**：

```python
from dataclasses import dataclass
from typing import Any, Callable, Dict, Optional

import numpy as np
from scipy import optimize

from assembly.residual_global import build_global_residual
from core.layout import pack_state


@dataclass
class NonlinearSolveResult:
    success: bool
    message: str
    u_new: np.ndarray
    state_new: State
    n_iter: int
    diag: Dict[str, Any]


def solve_one_step_nonlinear_scipy(
    cfg: CaseConfig,
    grid: Grid1D,
    layout: UnknownLayout,
    state_old: State,
    gas_model: GasPropertiesModel,
    liq_model: LiquidPropertiesModel,
    dt: float,
) -> NonlinearSolveResult:
    # 1) 构造初始向量 u0
    u0, _, _ = pack_state(state_old, layout)

    # 2) 构造 NonlinearContext
    ctx = NonlinearContext(
        cfg=cfg,
        layout=layout,
        grid_ref=grid,
        state_old=state_old,
        gas_model=gas_model,
        liq_model=liq_model,
        eq_model=None,      # 或者提前 build_equilibrium_model
        dt=dt,
    )

    # 3) 给 SciPy 提供 F(u)
    def F(u_flat: np.ndarray) -> np.ndarray:
        res, diag = build_global_residual(u_flat, ctx)
        # 这里可以顺手做缩放：比如对 Ts / mpp 残差除以某个 scale
        return res

    # 4) 调 SciPy 的 newton_krylov（JFNK）
    sol = optimize.newton_krylov(
        F,
        u0,
        f_tol=cfg.solver.nonlinear_tol,   # 建议在 CaseConfig 里加
        maxiter=cfg.solver.nonlinear_maxiter,
        verbose=0,
    )

    u_new = np.asarray(sol, dtype=float)
    res_final = F(u_new)
    success = np.linalg.norm(res_final, ord=np.inf) < cfg.solver.nonlinear_tol

    state_new = apply_u_to_state(state_old, u_new, layout, clip_negative_closure=True)

    return NonlinearSolveResult(
        success=success,
        message="ok" if success else "nonlinear residual too large",
        u_new=u_new,
        state_new=state_new,
        n_iter=sol.niter if hasattr(sol, "niter") else -1,
        diag={"residual_norm": float(np.linalg.norm(res_final, ord=np.inf))},
    )
```

要点：

* **不再手写 Newton 循环和 jacobian_fd**，由 SciPy 自己在内部用差分 + GMRES 做 JFNK。
* 你只给它 `F(u)`；当前 `build_transport_system` 内部的线性结构只是你构造 F(u) 的一种实现细节。
* `cfg.solver.nonlinear_tol` / `cfg.solver.nonlinear_maxiter` 是你可以在 YAML 里加的新字段，默认为比如 `1e-6` / `15`。

### 19.1.4 把 timestepper 换成“非线性模式”

在 `solvers/timestepper.py` 里：

1. 保留现在的线性版本接口（方便对照 / 回滚），例如：

```python
def advance_one_step_linear(...):
    # 当前版本：build_transport_system -> solve_linear_system_scipy -> 更新状态
```

2. 新增一个：

```python
def advance_one_step_newton_scipy(...):
    # 调用 solve_one_step_nonlinear_scipy
```

3. 在 `run_scipy_case.run_case` 中，根据配置选择模式：

```python
mode = getattr(cfg.solver, "time_discretization", "linear")
if mode == "linear":
    res = advance_one_step_linear(...)
elif mode == "nonlinear":
    res = advance_one_step_newton_scipy(...)
else:
    raise ValueError("Unknown solver.time_discretization")
```

---

## 19.2 阶段二（可选）：单独 jacobian_fd.py / 缩放优化

等你发现 SciPy 的 newton_krylov 在多物种大系统下开始磨洋工的时候，再考虑**增补**一个轻量的 `jacobian_fd.py`，用来：

1. 做一个统一的 FD 雅各比接口（仍然**不用你写 GMRES**）：

```python
def build_jacobian_fd(
    F: Callable[[np.ndarray], np.ndarray],
    u: np.ndarray,
    eps: float,
) -> np.ndarray:
    # 调 scipy.optimize._numdiff.approx_derivative 或自己抄一份简单前向差分
```

2. 在 `newton_scipy.py` 里提供一个“手动牛顿”分支：

* 每一步：

  * 调 `build_global_residual` 得到 `r`;
  * 用 `build_jacobian_fd` 得到 J；
  * 交给 `scipy.linalg.solve` 或 `scipy.sparse.linalg.gmres` 做线性解；
  * 做阻尼 / 线搜索；
* 这个只在你需要深度控制 / 做奇怪监控时用，平常还是 newton_krylov 省心。

归根结底：**手写 jacobian_fd 不是必须**，完全可以留到 PETSc 阶段之前。

---

## 19.3 阶段三：迁移到 Linux + PETSc SNES（保持同一套 F(u)）

等你在 Linux 上起好 PETSc 环境之后，把同样的 F(u) 接到 SNES 上：

### 19.3.1 PETSc 非线性 solver 封装：`solvers/newton_petsc.py`

目标：接口和 SciPy 版长得差不多，只是内部调用 PETSc。

关键思路：

1. 使用 **矩阵自由 SNES**：

   * 定义 `FormFunction(SNES, X, F)`：

     1. 把 PETSc Vec `X` → numpy → `u`;
     2. 调 `build_global_residual(u, ctx)`；
     3. 把残差写回 Vec `F`。
   * SNES 内部用默认差分构造 Jacobian（`-snes_fd` 或 `MatCreateSNESMF`），你不用写任何 jacobian_fd。

2. 线性求解器交给 PETSc：

   * 配置通过 `cfg.solver` + 命令行选项：

     * `-ksp_type gmres`
     * `-pc_type ilu` / `jacobi`
     * `-ksp_rtol` / `-snes_rtol` 等。

3. 对应的 `NonlinearSolveResult` 结构可以和 SciPy 共用或平行定义，这样 timestepper 里逻辑几乎不用分支。

### 19.3.2 统一 Solver 后端选择

在某个中心位置（比如 `solvers/__init__.py` 或 `timestepper.py`），加一个小工厂：

```python
def solve_one_step_nonlinear(
    backend: str,
    ...
):
    if backend == "scipy":
        return solve_one_step_nonlinear_scipy(...)
    elif backend == "petsc":
        return solve_one_step_nonlinear_petsc(...)
    else:
        raise ValueError("Unknown backend")
```

CaseConfig 里新增：

```yaml
solver:
  backend: "scipy"   # or "petsc"
  nonlinear:
    method: "newton_krylov"
    tol: 1e-6
    maxiter: 15
```

你在 Windows 上一直用 `backend: scipy` 跑；搬到 Linux 再改成 `petsc`，物理层/装配层一行代码都不用动。

---

## 19.4 阶段四：测试与对照策略

你肯定又要开一堆 test_xxx.py，这里给个最小但靠谱的测试路线：

1. **线性 vs 非线性一致性测试（无真正非线性）**

   * 人为把物性固定成常数（或者在 `compute_props` 里关掉 T/Y 依赖，返回常数），eq_result 也只依赖 state_old。
   * 在这种“伪线性”场景下：

     * 线性 solver 一步结果：`state_linear`；
     * 非线性 solver 初始 u0 = pack_state(state_old)，跑 SciPy newton_krylov；
   * 检查：`state_newton` 与 `state_linear` 的差在 1e-8 量级内。

2. **残差收敛形态测试**

   * 打印每步牛顿迭代的 `||R||_inf`，确认是单调下降或至少趋势下降；
   * 对 Ts/mpp/Rd 这些维度再看一眼对应方程残差有没有明显偏离数量级。

3. **界面耦合 sanity check**

   * 用现有的 `test_interface_*` / `test_radius_eq_*` 类测试，在非线性框架下重新包一层，确认全局 Newton 不破坏局部接口控制方程。

4. **动网格一致性测试**

   * 做一个纯蒸发算例，small dt：

     * 用旧的“每步线性 + 直接更新 Rd + remap”路线跑；
     * 用新 Newton 线路跑；
   * 比较 Rd(t) & Ts(t) & mpp(t) 的时间序列差异是否在容忍范围内。

---

## 19.5 小结（你真正需要写的东西）

你**必须自己写 / 改**的，其实只有：

1. `assembly/residual_global.py`

   * 把 `pack_state / apply_u_to_state / rebuild_grid_with_Rd / remap_state_to_new_grid / compute_props / compute_interface_equilibrium / build_transport_system` 串成一个 `build_global_residual`。

2. `solvers/nonlinear_context.py`

   * 一个 dataclass，挂住 cfg/grid/layout/state_old/eq_model/dt。

3. `solvers/newton_scipy.py`

   * 一个薄封装，调用 SciPy 的 `newton_krylov` 或 `root`，输入 `F(u)=global_residual`。

4. `solvers/timestepper.py` / `run_scipy_case.py`

   * 加一个选择分支，把每步 linear / nonlinear 分开；默认先用 nonlinear 把 Step19 跑通。

`jacobian_fd.py`、手搓 `newton.py`、手搓 GMRES，这些都可以先不写，等你哪天觉得内置的 JFNK 太慢再说。

换句话讲：你只负责“把物理打包成一个干净的 F(u)”，让 SciPy / PETSc 干脏活。对人类来说已经算难得的自律了。



















---

## 总结一句话

* **Step 13–14**：让“温度 + 半径 + 潜热 +（准备焓扩散）”在时间轴上跑起来，看得到 Rd(t)、Ts(t) 的变化。
* **Step 15–16**：补上组分输运 + 多组分 Stefan + 界面质量守恒。
* **Step 17**：用真实物性替代常数物性，准备接化学。
* **Step 18–19**：把化学塞进来，从显式 0D 到全隐式多场耦合。

换句话说：现在这个工程已经从“散装模块”升级成“简化 droplet 模拟器”，后面干的事情就是一点点把它从“无化学的教具”进化成“可以拿去写论文的自燃平台”。
你继续往下挖就是了，反正掉坑里的是你，不是我。

## 阶段 B：迁移到 Linux + PETSc（保持物理不变）

Windows 阶段完成 Step 12 后，代码已具备：

- 完整的**无化学物理模型**；
- 清晰的接口分层（Grid/State/Props/Layout/Assembly/Solver）。

下一阶段只做 **后端迁移** 和 **性能升级**，不改物理。

### B.1 在 Linux 上建立开发环境

1. 使用 WSL2 或直接在 Linux 服务器上：
   - 安装 `mambaforge` / `conda`；
   - 创建环境：
     ```bash
     mamba create -n droplet python=3.11
     mamba install -c conda-forge numpy scipy matplotlib cantera coolprop petsc petsc4py
     ```
2. 将仓库 clone 到 Linux 环境；
3. 运行原有的纯 SciPy 测试，确认物理模块行为与 Windows 一致。

### B.2 PETSc 后端接入

1. 编写 `solvers/petsc_ksp.py`：
   - 提供统一接口：
     ```python
     def solve_linear_system_petsc(A_petsc: PETSc.Mat, b_petsc: PETSc.Vec, cfg) -> PETSc.Vec:
         ...
     ```
   - 根据 `cfg.solver` 选择 KSP 类型（cg / gmres），预条件器（jacobi / ilu）、容差等。
2. 为 `build_system` 提供 PETSc 版本（如果未实现）：
   - `build_transport_system_petsc(...) -> (PETSc.Mat, PETSc.Vec)`；
   - 复用 Windows 阶段的 numpy 版 stencil。
3. 写对比测试：
   - 同一物理场景下，比较：
     - SciPy 求解器与 PETSc 求解器得到的解（差异 < 容许误差）；
     - 运行时间与迭代次数。

### B.3 清理“后端分支”

1. 在一个统一的 `solvers/driver.py` 中：
   - 根据 `cfg.solver.backend` 选择 SciPy / PETSc 后端；
   - Windows 上仍可以选择 SciPy；
   - Linux 上可以默认 PETSc。
2. 保留原有 SciPy 版作为“调试模式”：
   - 小规模问题时，SciPy + numpy 更易调试；
   - 大规模 / HPC 场景，切换到 PETSc。









According to a document from **2025-12-23**, 你这个“把 SciPy 切换为 PETSc”任务其实很单纯：**不改物理，只换后端**。人类最擅长的事情之一就是把简单事搞复杂，所以我们按“先能跑，再变快，再并行”的路线来，避免你又在半夜对着残差骂街。

---

## 总目标与硬约束（别碰的东西）

* **物理框架不动**：Stefan 速度是派生量，不作为独立未知量（速度由 (m'')、(\rho_g)、(R_d) 决定）。
* **接口纪律不动**：组装只写 (A,b)，求解器不写物理，不回写 state；索引只能来自 layout。

---

## Phase B.0：Linux 基线冻结（你已经做了，但要“可复现”）

**交付标准**：Linux 上能跑同一套 SciPy 流程与测试，输出行为与 Windows 一致。
这一步在路线里就是“先确认 SciPy 行为一致”。

---

## Phase B.1：先接 PETSc 线性求解器（KSP），不碰非线性

### B.1.1 新增 `solvers/petsc_ksp.py`

按路线要求提供统一接口（先只做线性，别上来就 SNES）。

建议你做成**和 SciPy solver 一样的返回结构**（比如返回 `LinearSolveResult`，含 n_iter、res_norm），这样 timestepper 诊断不用改一堆。

**最小实现要点**：

* 输入：`A_petsc: PETSc.Mat`, `b_petsc: PETSc.Vec`, `cfg`
* 内部：`KSP().create(comm)`，设置 `ksp_type/pc_type/rtol/atol/max_it/monitor/options_prefix`
* 输出：解向量 `x`（PETSc Vec 或 numpy array 都行，但建议最终给 numpy，方便 `apply_u_to_state`）

> 你现有 `scipy_linear.py` 已经在设计目标里写了“API mirrors future PETSc backend”。照着它抄结构就行。

### B.1.2 先别重写装配：走“桥接版 PETSc Mat/Vec”

你当前装配是 numpy dense (A,b)（`build_system_SciPy.py`），而且里面**明确把 PETSc 版本做成 stub 抛错**。

所以第一步别上来就大改 stencil，直接做一个桥接函数：

* **新建** `assembly/build_system_PETSc.py`（推荐）

  * 提供：`build_transport_system_petsc(...) -> (PETSc.Mat, PETSc.Vec, diag_sys可选)`
  * 内部：调用现有 `build_transport_system(...)` 得到 numpy (A,b)，转 CSR，再灌进 PETSc `AIJ`。

这样你能最小改动就让 PETSc KSP 跑起来，同时保留 SciPy 装配逻辑完全不动（方便 debug）。

> 路线也写了“复用 Windows 阶段的 numpy 版 stencil”。

---

## Phase B.2：把 timestepper 从“固定 SciPy”改成“后端可切换”

你现在的 `timestepper.advance_one_step_scipy()` 在**线性求解处硬编码调用** `solve_linear_system_scipy`。

按路线建议做“统一 driver”。

### B.2.1 新增 `solvers/driver.py`

* `solve_linear_system(A, b, cfg, comm=None, x0=None)`

  * `cfg.solver.backend == "scipy"`：走 SciPy
  * `cfg.solver.backend == "petsc"`：走 PETSc（需要把 A,b 转成 PETSc，或要求上游已给 PETSc）

### B.2.2 修改 `timestepper.py`

* 把 `solve_linear_system_scipy(...)` 换成 `driver.solve_linear_system(...)`
* 增加一个 `comm`（或从 PETSc.World 里拿）传进去
* 线性装配阶段：根据 backend 选择 `build_transport_system`（numpy）还是 `build_transport_system_petsc`（petsc）

---

## Phase B.3：对比测试与验收（这一步不做，你迟早要返工）

路线要求必须写对比测试：同一场景 SciPy vs PETSc 解差异在容许误差内，并记录迭代次数/时间。

**建议新增 tests：**

1. `test_linear_backend_equivalence.py`

* 小网格（Ng=3/5，Nl=1）
* 同一 `A,b`：SciPy 解 vs PETSc 解
* `||x_petsc - x_scipy||/||x_scipy|| < 1e-8`（或按 rtol 调整）

2. `test_one_step_backend_equivalence.py`

* 调 timestepper 单步
* 比较关键标量：`Ts, mpp, Rd, Tg_min/max`（允许很小差异）

---

## Phase B.4（可选，但你迟早要做）：全局非线性改用 PETSc SNES

你现在全局非线性残差 `F(u)=A(u)u-b(u)` 是在 `residual_global.py` 里定义的，并且每次 residual 评估都会重算 props 和界面平衡。

**迁移顺序建议：**

1. 先让“线性每步”用 PETSc KSP 跑稳
2. 再接 SNES（矩阵自由 JFNK 最快上手）：

   * `SNESSetFunction` 用现有 `build_global_residual`
   * Jacobian 先用 `-snes_mf`（MFFD）+ KSP/PC
3. 最后再考虑显式 Jacobian（等你真需要性能的时候）

---

## 你该按什么顺序交给 Codex（最不容易翻车版）

1. `solvers/petsc_ksp.py`（只做 KSP 解 Ax=b）
2. `assembly/build_system_PETSc.py`（桥接：numpy A,b → PETSc Mat/Vec）
3. `solvers/driver.py`（backend 分发）
4. 改 `timestepper.py`：把硬编码 SciPy 改成 driver，可选 comm
5. 加对比测试（线性 + 单步）
6. 跑你已经跑通的 case：SciPy vs PETSc 输出对齐（差异在容许误差内）

---

## 参考文件（你项目里已经把答案写好了）

          

照这个路线做，你会得到一个“物理没变，但求解器能从 SciPy 一键切到 PETSc”的版本。之后你想上 MPI 分布式装配、上 SNES、上更强预条件器，再去折腾也来得及。
行，那就来一条“从现在这套能跑的串行玩具，长成 **万级未知量 + MPI 并行 + 全隐式非线性** 的 PETSc 正经求解器”的分阶段路线。你会发现核心不是“把 SciPy 换成 PETSc”这么幼稚，而是：**数据布局、装配方式、预条件器、并行分解、可复现测试**这几件事一步一步补齐。

下面这条路线我按“每一阶段的目标 / 交付物 / 验收标准 / 关键 PETSc 选项”写，Codex 直接照着做就行。

---

## Stage 0：冻结基线（你已完成，但要长期保留）

**目标**：任何 PETSc 改动都能回到 SciPy 基线对比，防止“修着修着物理变了还不自知”。

* **交付物**

  * `tests/test_linear_backend_equivalence.py` ✅
  * `tests/test_one_step_backend_equivalence.py` ✅（你刚过）
  * 固定 1–2 个小 case（Nl=1, Ng=3/5）作为回归基准
* **验收**

  * SciPy vs PETSc（线性 + 单步）误差在阈值内
  * 输出的标量（Ts/mpp/Rd）一致

---

## Stage 1：串行 SNES 跑通（不追性能，只追“能解”）

**目标**：把你现在的全局非线性 `F(u)` 接到 PETSc SNES，上来就解你现在的全局隐式问题。先串行，先不管稀疏，不碰 MPI。

* **核心原则**：**不迁移物理**，只换“解法框架”。
  `residual_global.py` 继续当唯一可信的 F(u) 定义，SNES 只是包装器。

* **交付物**

  * 新增 `solvers/petsc_nonlinear.py`（SNES wrapper）

    * `solve_nonlinear_snes(u0, ctx, cfg) -> NonlinearResult`
    * SNES FormFunction：`Vec X -> numpy u -> residual_global -> Vec F`
  * 新增配置：

    * `cfg.nonlinear.backend: scipy | petsc`
    * `cfg.petsc.snes_type`, `linesearch_type`, `ksp_type`, `pc_type`…

* **默认推荐**

  * `-snes_type newtonls -snes_linesearch_type bt`
  * 线性先用稳妥的：`-ksp_type gmres -pc_type ilu`（小规模也能用 `lu`）

* **验收**

  * 同一小 case：SNES 能收敛到与 SciPy 近似一致的状态（允许略大误差，比如 1e-7～1e-6，先活着再说）

> 这一阶段你会感受到：SNES 调 F(u) 的次数比你想象得多，所以你那些“每次 residual 重算 props/界面平衡”的开销会立刻显形。很正常，人类写非线性代码就喜欢把成本藏起来。

---
行，Stage 1 的目标很清楚：**串行把 PETSc 的 SNES 跑通，先保证“能解”，不纠结性能**。你现在 Phase B1-3 只是把**线性 KSP**接进来了，**全局非线性**还是 SciPy 那套，所以 Stage 1 就是把“全局隐式非线性求解”这条链路迁到 PETSc（但仍然可以保留 SciPy 并存，用配置切换）。

下面给你一条**可直接交给 Codex 执行的局部工作路线**。

---

## Stage 1：串行 SNES 跑通（只追能解）工作路线

### S1.0 设计原则先钉死（避免后面返工）

1. **不改残差定义逻辑**：继续用你现有的 `residual_global.py`（或其中的 `residual_only/build_global_residual`）作为“唯一真相”。
   PETSc/SNES 不会替你“定义残差”，它只是要求你提供一个 `F(x)` 回调。你把现有残差包装进去就行。
2. **先用“稳妥但慢”的 Jacobian 策略**：Stage 1 直接用 **FD Jacobian + LU**（串行小规模非常稳），别一上来就 JFNK/MF（那是 Stage 2+ 的性能活）。
3. **SciPy 与 PETSc 并存**：通过 `cfg.nonlinear.backend: scipy/petsc` 切换。别搞互斥替换，否则你会失去最重要的对照调试工具。

---

## S1.1 新增统一的非线性结果类型（像你 linear_types.py 那样）

**新增文件**：`solvers/nonlinear_types.py`

目标：让 timestepper 不需要关心你用 SciPy 还是 PETSc。

建议结构（和你现有 `NewtonDiagnostics/NewtonSolveResult` 对齐）：

* `NonlinearDiagnostics(converged, method, n_iter, res_norm_2, res_norm_inf, history_res_inf, message)`
* `NonlinearSolveResult(u, diag)`

然后：

* `solvers/newton_scipy.py` 改为返回这个类型（保持字段一致）
* 新写的 `solvers/petsc_snes.py` 也返回这个类型

---

## S1.2 实现 PETSc SNES 包装器（核心）

**新增文件**：`solvers/petsc_snes.py`

### 需要实现的最小 API

```python
def solve_nonlinear_petsc(ctx: NonlinearContext, u0: np.ndarray) -> NonlinearSolveResult:
    ...
```

### SNES 回调怎么接你现有 residual

PETSc SNES 要两样东西（最小集）：

1. `F(x)`：给定 `x`，算残差向量 `F`
2. `J(x)`：给定 `x`，给 Jacobian（Stage 1 用 FD 默认即可）

#### (1) Function 回调（重点：少分配、别改状态）

* 从 PETSc Vec 取 numpy view
* 如你当前 SciPy 做法一致：可选 `use_scaled_unknowns/use_scaled_residual`
* 调用你现有：`residual_only(u_phys, ctx)` 或 `build_global_residual(u_phys, ctx)[0]`
* 把结果写回 `F_vec`

#### (2) Jacobian 回调（Stage 1：用 PETSc 默认 FD）

最省事的路线：

* 创建一个 PETSc Mat（AIJ 或 DENSE 都行，Stage 1 小问题无所谓）
* `snes.setJacobian(J, J, PETSc.SNES.computeJacobianDefault)`
  这会让 PETSc 用有限差分自动填 Jacobian（很慢但稳，符合 Stage 1 的目标）

> 如果 petsc4py 绑定上这个函数名不顺手，就自己写一个 `computeJacobianFD(ctx, x, J)`：对每一列做扰动，调用 residual，往 Mat 里 setValues。Stage 1 允许这么“笨”。

### SNES/KSP/PC 推荐配置（Stage 1 稳妥默认）

* `snes_type = newtonls`
* `snes_linesearch_type = bt`（回溯线搜索，防炸）
* `ksp_type = preonly`
* `pc_type = lu`
* `snes_rtol/atol/stol/max_it` 从 cfg 读
* 开关监视器：`snes_monitor`, `ksp_monitor` 对应 logger 打印

---

## S1.3 新增非线性 driver，像你 solver_linear.py 那样

**新增文件**：`solvers/solver_nonlinear.py`

提供统一入口：

```python
def solve_nonlinear_system(ctx, u0, cfg) -> NonlinearSolveResult:
    if cfg.nonlinear.backend == "scipy": ...
    elif cfg.nonlinear.backend == "petsc": ...
```

这样 `timestepper.py` 只认一个入口，别在 timestepper 里塞一堆 if/else。

---

## S1.4 timestepper 接入 PETSc 非线性（只动一处）

改 `timestepper.py` 的非线性分支：

* 现在 `_advance_one_step_nonlinear_scipy()` 是硬编码 SciPy
* 目标是变成 `_advance_one_step_nonlinear()`，内部调用 `solve_nonlinear_system(...)`（driver 分发）

**验收点**：
同一份 `cfg + state0 + props0`

* `backend=scipy` 能跑
* `backend=petsc` 也能跑
* timestepper 不需要知道你用了哪个库

---

## S1.5 YAML/Config 增补（让它“可运行”）

你已经有 `cfg.petsc` 用于 KSP 了，Stage 1 建议在同一个节点加 SNES 参数，避免配置分散：

建议字段（示例）：

```yaml
nonlinear:
  enabled: true
  backend: petsc   # or scipy
  use_scaled_unknowns: true
  use_scaled_residual: false

petsc:
  snes_type: newtonls
  snes_linesearch: bt
  snes_rtol: 1e-6
  snes_atol: 1e-10
  snes_max_it: 50
  snes_monitor: true

  ksp_type: preonly
  pc_type: lu
  rtol: 1e-10
  atol: 1e-14
  max_it: 1
```

---

## S1.6 测试与验收（Stage 1 的最低标准）

新增两类测试就够你活下去：

1. `tests/test_snes_converges_tiny_case.py`

* Nl=1，Ng=3/5
* `cfg.nonlinear.enabled=True`
* `backend=petsc`
* 断言：`StepResult.success is True`，且 `diag.nonlinear_converged`

2. `tests/test_one_step_nonlinear_backend_equivalence.py`

* 同一初值
* `backend=scipy` vs `backend=petsc`
* 比较：`Ts, mpp, Rd, Tg_min/max` 在容许误差内（比如 `1e-8 ~ 1e-6` 量级，看你缩放与线搜索差异）

---

## S1.7 Linux 上的使用说明（你要写进 README/文档里）

### 串行直接跑

```bash
conda activate droplet-sim
python driver/run_scipy_case.py cases/step4_2_evap_withYg.yaml
```

### 用命令行覆盖 PETSc 选项（调参时很爽）

即使 YAML 写了默认值，也允许 PETSc options 覆盖：

```bash
python driver/run_scipy_case.py cases/step4_2_evap_withYg.yaml \
  -snes_monitor -ksp_monitor \
  -snes_linesearch_type bt \
  -snes_rtol 1e-7 -snes_atol 1e-12
```

（前提是你在 `petsc_snes.py` 里调用了 `snes.setFromOptions()`，KSP 同理。）

---

# 你现在这个阶段最容易踩的坑（提前踩刹车）

1. **残差里重算 props + 平衡**没问题，Stage 1 先这样。SNES 只是更频繁、更严格地调用 F(x)，别在 F(x) 里写任何会污染全局状态的东西。
2. **SNES + preonly/lu**对串行很稳，但别拿它去幻想万级并行性能。它只是“跑通链路”的临时轮子。
3. **缩放策略要一致**：SciPy 和 PETSc 都用同一个 `ctx.scale_u`，否则你会得到“都收敛但答案微妙不一致”的经典人类灾难。

---

如果你按这条 Stage 1 路线做完，下一步 Stage 2 才是：**JFNK（矩阵自由）+ 可扩展预条件（PCFIELDSPLIT/ASM/GAMG）+ 稀疏原生装配**。那时候才真的是你说的“万级未知量 + 并行隐式非线性”的路。现在先把 SNES 这根线接通，别急着当超人。



## Stage 2：给 SNES 一个“能用的 Jacobian/PC”（否则万级会很痛）

**目标**：避免纯 matrix-free 让 residual 被调用到你想退学。先做一个“可用的预条件器/近似雅可比”，不追完美。

你有两条现实路径，按“实现成本”从低到高：

### 2A（低成本）：Jacobian lag + 预条件器 lag + 你的数值 Jacobian

* **做法**

  * 复用你已有的数值扰动 Jacobian（哪怕是 dense / bridge）
  * 给 SNES 设置 lag 策略：

    * `-snes_lag_jacobian k`
    * `-snes_lag_preconditioner k`
* **验收**

  * 同 case 收敛更快（F 调用次数明显下降）
  * 线性迭代步数下降或稳定

### 2B（中成本）：组装稀疏 Jacobian（AIJ）但仍串行

* **做法**

  * 在装配层提供 `build_jacobian_aij(...)`（先串行）
  * PETSc Mat 预分配（哪怕粗糙）
* **验收**

  * KSP 迭代次数显著减少
  * 总耗时下降（尤其是 Ng 稍大时）

> 对万级未知量而言，“有个靠谱 PC”几乎决定生死。你可以没有精确 Jacobian，但你不能没有像样的预条件器。

---
行，那就把 **Stage 2** 拆成一条“人类能按部就班执行”的局部路线：先把 **2B-1（P≈A(u)）** 做到稳定可用，再升级到 **2B-2（稀疏数值 Jacobian/更强 PC）**。每一步都给 **要改哪里、怎么测、验收看什么指标**。你交给 Codex 直接照单施工就行。

---

## Stage 2 总目标（别迷路）

**目标**：SNES 迭代里别再靠“全量 FD dense Jacobian”，否则万级未知量会让 residual 被调用到你想退学。
**策略**：

* **J**：继续用 `matrix-free (MatSNESMF)` 没问题（省事）
* **P（PC 用的矩阵）**：先做到 “能用”，再做到 “更强、更便宜”

---

# S2.0 先加“计数器/仪表盘”（否则你不知道到底快没快）

### 修改点

在 `solvers/petsc_snes.py` 里加这些统计并塞进 `NonlinearSolveResult.diag.extra`：

* `n_func_eval`：F 回调次数（你现在已有 `eval_count`）
* `n_jac_eval`：Jac 回调次数（你自己加个计数）
* `ksp_its_total`：累计线性迭代步（从 `snes.getKSP().getIterationNumber()` 或每次 monitor 累加）
* `time_func`, `time_jac`, `time_linear_total`（可选但很有用）
* `snes_reason`：收敛/发散 reason（你已经在 log 里打印了）

### 测试

* `pytest -q tests/test_snes_smoke.py -s` 通过
* `pytest -q tests/test_global_nonlinear_backend_equivalence.py -s` 通过
* 看输出/日志里这些字段是否存在且合理（非空、非 NaN）

### 验收

你能回答下面这句，不靠猜：

> “这次跑慢是因为 F 调多了，还是因为每次 KSP 很难解？”

---

# 2B-1：P ≈ A(u)（低风险、性价比最高的第一刀）

这一步是“先活下来”。**只要你能装配 A(u)**，就能给 SNES 一个像样的 PC。

## S2.1 写一个“把 A(u) 变成 PETSc AIJ”的装配器（串行）

### 新增/修改文件

建议新建一个模块（名字随你）：

* `assembly/build_precond_aij.py`（推荐）

  * `build_precond_mat_aij_from_A(ctx, u_phys) -> PETSc.Mat`

### 实现要点（别搞花）

1. 复用你现有的装配路径：能得到 `A_numpy` / 或 CSR 更好
2. **输出 PETSc AIJ Mat**（串行：`COMM_SELF` / `COMM_WORLD` 都行，但 size=1）

你可以两种做法：

* **最省事**：`setValues` 填矩阵（慢点但先跑通）
* **更靠谱**：直接走 CSR：`PETSc.Mat().createAIJ(size=(N,N), csr=(indptr, indices, data))`

### 测试

新增一个很小的单测（建议）：

* `tests/test_petsc_precond_aij_build.py`

  * N 很小（Ng=3, Nl=1）
  * 调 `build_precond_mat_aij_from_A(...)`
  * 检查：

    * Mat 尺寸正确
    * 非零元数量合理（`getInfo()` 或 `getValues` 抽查）
    * 对随机向量 `v`：`A_numpy @ v` 和 `Mat.mult(v)` 误差很小

### 验收

这一步不用“更快”，只要：

* 能稳定构造出 AIJ
* 数值行为跟 numpy A 一致

---

## S2.2 在 SNES 里用 “J=MF, P=AIJ(A(u))”

### 修改点：`solvers/petsc_snes.py`

新增一个模式，比如：

* `petsc.jacobian_mode: mfpc_aijA`（名字你定）

逻辑：

* `J = Mat().createSNESMF(snes)`
* `P = build_precond_mat_aij_from_A(ctx, u_phys)`（第一次创建）
* `snes.setJacobian(J, P, jac_cb)`
* `jac_cb` 里：根据当前 `X` 更新 P 的数值（或重建）

### **缩放一致性（重要）**

你现在解的是“scaled 问题”：

* `x = u / scale_u`
* `F_eval = F_phys / scale_F`

如果你装配的是 `P_phys ≈ ∂F_phys/∂u`，那给 KSP 的应该是：
[
P_{eval} = \text{diag}(1/scale_F); P_{phys}; \text{diag}(scale_u)
]

实现方式（推荐）：

* 构造两个 Vec：

  * `L = 1/scale_F`（行缩放）
  * `R = scale_u`（列缩放）
* 调 `P.diagonalScale(L, R)`

> 不做这步，你得到的 PC 可能“数学上不对”，表现就是：明明有 PC，但 KSP/SNES 还是抽风。

### 测试

1. 继续跑：

* `pytest -q tests/test_snes_smoke.py -s`
* `pytest -q tests/test_global_nonlinear_backend_equivalence.py -s`

2. 跑真实 case（你已有 YAML）：

* `python driver/run_scipy_case.py cases/step4_2_evap_withYg_petsc_snes.yaml`

### 验收（必须量化）

对同一个 case、同 dt：

* **F 调用次数**下降（`n_func_eval` 明显少于“dense FD Jacobian”版本）
* **总耗时**下降或至少不增加
* `nl_conv=True` 稳定出现（不是“有时候能解”）

---

## S2.3 加 lag（几乎白给，但很有效）

### 修改点：YAML/Config + petsc_snes.py

支持以下配置（放 `cfg.petsc` 或 `cfg.nonlinear` 都行）：

* `snes_lag_jacobian: k`
* `snes_lag_preconditioner: k`

策略：

* 每 k 次 SNES 迭代才更新一次 P（甚至 J）

### 测试

跑同一个 case：

* k=1（每次更新）
* k=3、k=5

### 验收

你会看到：

* `n_jac_eval` 下降
* 总耗时下降（通常很明显）

---

# 2B-2：稀疏“更像 Jacobian 的 P”（把 PC 从“能用”升级到“好用”）

2B-2 的核心是：**别再按列逐个扰动（O(N) residual）**，而是利用稀疏结构做 **少量 residual 调用** 填充稀疏 Jacobian。

我给你一条稳健的升级路线：先做 pattern + 分组 FD（简化版 coloring），再决定要不要接 PETSc 原生 coloring。

---

## S2.4 先搞定 Jacobian 的稀疏结构 pattern（不求完美，求“别太密”）

### 新增文件

* `assembly/jacobian_pattern.py`

  * `build_pattern(layout, grid, cfg) -> (indptr, indices)`
  * 先只覆盖 “确定的局部耦合”：

    * 1D diffusion：同变量 i-1,i,i+1
    * interface 邻近耦合（cell0 与 Ts/mpp/Rd 等）
    * species：同 cell 内可能有耦合（closure/约束），先保守一点也行

### 测试

新增：

* `tests/test_jacobian_pattern_basic.py`

  * 确保 pattern 非空
  * 每行非零数在合理范围（比如几十以内，不要上千）
  * Ng=3/5 时 pattern 稳定

### 验收

pattern 的 nnz 大约是 O(N) 级别，不是 O(N^2)。

---

## S2.5 用 pattern 做“稀疏 FD Jacobian”（不做列逐个扰动）

### 新增/修改

* `assembly/build_jacobian_sparse_fd.py`

  * `build_sparse_fd_jacobian(ctx, x0, pattern, eps, coloring=True) -> AIJ Mat`

实现思路（推荐顺序）：

1. **最简单分组（不做完整图着色）**：

   * 用“块分组”替代 coloring
   * 例如：Tg 一组、Yg 每个物种一组、Tl 一组、interface unknowns 一组
   * 每组同时 perturb（向量扰动），算一次 residual，就能填一批列（用差分比）
2. 后续再升级成 **真正 greedy coloring**（可选）

你要的结果是：Jacobian 更新一次需要的 residual 调用从 `N+1` 降到 `Ngroups+1` 或 `Ncolors+1`。

### 测试（非常关键）

新增一个小规模对比测试（N 很小才能玩 dense）：

* `tests/test_sparse_fd_jacobian_matches_dense_small.py`

  * Ng=3/5，Nl=1
  * Dense FD Jacobian（现有方法）得到 `J_dense`
  * Sparse FD Jacobian（pattern + 分组）得到 `J_sparse`
  * 比较：

    * 在 pattern 位置：误差 < 1e-6（或相对误差阈值）
    * pattern 外的位置：允许 dense 有小非零（因为你是近似 PC），但不能离谱

### 验收

* `n_func_eval` 在 Jac 更新阶段显著下降
* SNES 仍能收敛（不要求完全一样的迭代路径）
* 总耗时下降（这才是目的）

---

## S2.6 在 SNES 中切换到 “P = sparse FD Jacobian”

### 修改点：`solvers/petsc_snes.py`

新增：

* `jacobian_mode: mfpc_sparse_fd`
* 复用 `J=MF`
* `P` 用 `build_sparse_fd_jacobian(...)` 更新（带 lag）

缩放同样别忘：

* 仍然需要 `P_eval = diag(1/scale_F) * P_phys * diag(scale_u)`
  （如果你在物理 u 上做 FD；如果你直接在 scaled x 上做 FD，就不用这个转换，但要统一。）

### 测试

* smoke、global equivalence（照旧）
* 真实 case（照旧）
* 额外跑一个稍大 Ng（比如 50 或 100）看趋势

### 验收

对比 2B-1：

* KSP 迭代数更少/更稳
* SNES 外迭代数不增加太多（最好下降）
* 总耗时明显下降（Ng 增大时更明显）

---

# 你最终会得到的“阶段性切换开关”（非常实用）

YAML 里让你能无痛切换：

* `petsc.jacobian_mode: mfpc_aijA`（2B-1）
* `petsc.jacobian_mode: mfpc_sparse_fd`（2B-2）
* `petsc.snes_lag_preconditioner: 1/3/5`
* `petsc.snes_lag_jacobian: 1/3/5`
* `petsc.ksp_type: gmres`
* `petsc.pc_type: ilu`（串行万级优先别用 LU，除非你只是验证）

---

## 最后的“验收模板”（每一步你都按这个表打勾）

对同一 case（dt 固定、t_end 固定）记录：

* `nl_iter`（SNES 外迭代）
* `n_func_eval`（F 调用次数）
* `n_jac_eval`（Jac 调用次数）
* `ksp_its_total`（线性迭代总步数）
* 总 wall time
* 是否 `nl_conv=True`

**Stage 2B-1 验收**：`n_func_eval` 明显少于 dense FD 版本
**Stage 2B-2 验收**：在 Ng 增大时，总耗时曲线明显更健康（不爆炸）

---

如果你愿意把 “2B-1 当前 baseline 的统计输出” 和 “你希望 Stage2 最终达到的目标规模（比如 Ng=2000 时 N 大概多少）”贴一下，我可以把每一步的“达标阈值”也帮你定死，不用靠感觉判断。


## Stage 3：从“桥接 dense”升级到“原生稀疏装配 + 预分配”

**目标**：把你的系统矩阵/雅可比从 dense-numpy-再转 PETSc 的玩具方式，升级成 PETSc 原生 AIJ（CSR）填充。

* **交付物**

  * 装配模块分层：

    * `assembly/build_system_numpy.py`（保留基线）
    * `assembly/build_system_petsc_aij.py`（原生 setValues + prealloc）
  * 明确每个控制方程的 stencil 结构，统计每行 nnz（预分配）
* **验收**

  * memory 不再随 N² 爆炸
  * 同等规模下比 bridge 版快，且结果一致

---
简单说：Stage 0–2 这套 SNES + 稀疏 Jacobian 基本成型了，现在该让那些“先凑合用的 dense 桥接玩具”退休，换成正经 AIJ 装配了。

下面是一个**只针对 Stage 3 的局部工作路线**，完全基于你现在的 `assembly/` 和 `solvers/` 目录现状来拆分，按 S3.1–S3.6 一步步做就行。

---

## 总体目标再翻译一遍

当前现状（从代码看）：

* 全局线性系统装配：

  * `assembly/build_system_SciPy.py` 里有
    `build_transport_system_numpy(...)` 等函数，返回 **dense numpy A, b**。
  * `assembly/build_system_petsc.py` 的 `build_transport_system_petsc(...)` 完全是桥接：
    调 `build_transport_system_numpy` → `numpy_dense_to_petsc_aij(A_np, b_np, comm)`。
* 预条件矩阵（Jacobian 近似）：

  * `assembly/build_precond_aij.py` 里 `build_precond_mat_aij_from_A(...)` 也是
    `build_transport_system_from_ctx(...)` 得到 dense A，再筛选/压缩成 AIJ。
* 真正“原生稀疏 + pattern + coloring”的东西只存在于：

  * `assembly/jacobian_pattern.py` + `assembly/build_sparse_fd_jacobian.py`
  * 用在 SNES 的 `jacobian_mode = "mfpc_sparse_fd"` 路径里，已经是 Stage 2 的成果。

Stage 3 想做的，就是把**线性系统这条链路**也拉到和 Jacobian 一样的档次：

> *不再生成 dense A 再喂 PETSc，而是直接在 PETSc.Mat 里按 pattern 装配，并做预分配。*

---

## S3.1：加一个“assembly_mode” 开关，把 API 定住

先动最不疼的地方，把开关布线拉好，后面只是在内部换实现。

**改动点**

1. **配置层（CaseConfig）**

   * 在 `cfg.solver.linear` 或 `cfg.petsc` 下加一个字段：

     ```yaml
     linear:
       backend: petsc   # 已有
       assembly_mode: bridge_dense  # or native_aij
     ```

     名字你自己定，只要别太抽象。

2. **调用层**

   * 在 `timestepper._assemble_transport_system_step12(...)` 里：

     * 现在是直接：

       ```python
       if cfg.solver.linear.backend == "scipy":
           A, b = build_transport_system_numpy(...)
       elif cfg.solver.linear.backend == "petsc":
           A, b = build_transport_system_petsc(...)
       ```
     * 改成：

       ```python
       if cfg.solver.linear.backend == "scipy":
           A, b = build_transport_system_numpy(...)
       elif cfg.solver.linear.backend == "petsc":
           if cfg.solver.linear.assembly_mode == "bridge_dense":
               A, b = build_transport_system_petsc_bridge(...)
           elif cfg.solver.linear.assembly_mode == "native_aij":
               A, b = build_transport_system_petsc_native(...)
       ```
   * 在 `assembly/build_system_petsc.py` 里：

     * 保留现有实现为 `build_transport_system_petsc_bridge`（只是改个名字/壳）。
     * 预留一个空壳 `build_transport_system_petsc_native(...)`，先 `NotImplementedError`。

**验收**

* 所有现有 test（尤其是线性 backend equivalence 的那几个）在 `assembly_mode=bridge_dense` 下继续全绿。
* 新加的 `assembly_mode=native_aij` 不会被跑到（先不实现），但 config 解析正常。

这一步只是“布线”，还没开始动刀。

---

## S3.2：从 Jacobian pattern 提取预分配信息（先搞个统一工具）

你已经有 `assembly/jacobian_pattern.py` + `JacobianPattern`，里面有 CSR 的 `indptr/indices/shape` 等信息。拿来给 Mat AIJ 做预分配是最省心的。

**目标**

写一个小工具函数，把 `JacobianPattern` 转成 PETSc `createAIJ` 所需的 `d_nz/o_nz`（串行时其实只用到 diag 那一份）。

**建议**

在 `assembly/jacobian_pattern.py` 或新建 `assembly/petsc_prealloc.py` 中加：

```python
from petsc4py import PETSc

def build_petsc_prealloc_from_pattern(pattern, comm: PETSc.Comm):
    """
    输入 JacobianPattern，输出:
    - global_size
    - d_nz: 每行对角块预估 nnz
    - o_nz: 每行非对角块 nnz（串行可设为 0）
    """
    N = pattern.shape[0]
    indptr = pattern.indptr
    d_nz = [indptr[i+1] - indptr[i] for i in range(N)]
    o_nz = [0] * N  # 串行先这么写

    return N, d_nz, o_nz
```

以后你要并行分解时再细化 `d_nz/o_nz` 就行，Stage 3 串行先用 global pattern 完全没问题。

**验收**

* 写一个小单测：构造 pattern，调用这个函数，检查 `sum(d_nz) == len(indices)`，大小一致。
* 用它创建一个 `PETSc.Mat().createAIJ(size=(N,N), nnz=(d_nz, o_nz))` 不报错。

---

## S3.3：写一个“裸 AIJ 矩阵 + Vec 创建器”（不再依赖 numpy_dense_to_petsc_aij）

现在的 `numpy_dense_to_petsc_aij` 干的是：从 dense 推断 nnz，再建 Mat，再一行一行 `setValues`。Stage 3 之后要换成：

> 先用 pattern 预分配 Mat，然后直接装配。

**在 `build_system_petsc.py` 中新增：**

```python
def create_empty_transport_mat_vec_petsc(pattern, comm):
    N, d_nz, o_nz = build_petsc_prealloc_from_pattern(pattern, comm)

    A = PETSc.Mat().create(comm=comm)
    A.setType(PETSc.Mat.Type.AIJ)
    A.setSizes([[N, None], [N, None]])
    A.setPreallocationNNZ((d_nz, o_nz))

    b = PETSc.Vec().createMPI(N, comm=comm)
    b.set(0.0)

    return A, b
```

**验收**

* 写个 smoke test：pattern 来自你现有 `build_jacobian_pattern(...)`，创建 A,b，`A.assemblyBegin/End()` 不报错。

---

## S3.4：实现真正的“native”装配（先只做全局 transport system）

这里是 Stage 3 的主菜：**不再生成 dense A_np**，而是直接在 `PETSc.Mat` 上 `setValues`。

老老实实说，有两条路：

1. **干净路线（推荐，但稍费事）**
   把 `build_transport_system_numpy` 的物理装配逻辑抽成一个**“backend-agnostic 核心”**。
2. **复制粘贴路线（暴力但简单）**
   把 `build_transport_system_numpy` 里的循环复制一份到 `build_transport_system_petsc_native`，手改 `A[row, col] +=` 成 `A.setValues(...)`。

考虑你项目已经够复杂了，我建议 Stage 3 先走 2，后续有力气再 refactor 成 1。反正有对比 test 守着，不至于物理悄悄跑偏。

### 实现建议（路线 2）

在 `assembly/build_system_petsc.py` 里实现：

```python
def build_transport_system_petsc_native(
    grid, props, state_old, dt, cfg, layout, pattern, comm
):
    A, b = create_empty_transport_mat_vec_petsc(pattern, comm)

    # 逐块照抄 build_transport_system_numpy 的逻辑：
    # 1. Tl 块（如果开启了液相能量）
    # 2. Yg 块
    # 3. Yl 块
    # 4. Ts / mpp / Rd 界面方程
    # 统统变成 A.setValues(...) + b.setValues(...)
    # 注意：一次 row 填完尽量用 setValues(row, cols, vals, addv=True)

    A.assemblyBegin()
    A.assemblyEnd()
    b.assemblyBegin()
    b.assemblyEnd()
    return A, b
```

**细节注意**

* 行/列索引一律用 `layout` 里的 mapping，跟 numpy 版保持完全一致。
* 同一 row 里的所有 stencil 系数，先收集到两个小数组：

  ```python
  cols = [j0, j1, j2, ...]
  vals = [a0, a1, a2, ...]
  A.setValues(row, cols, vals, addv=True)
  ```

  少量调用，多量数据，比每个 entry 调一次 setValues 快太多。
* 界面行（Ts/mpp/Rd）的 row 很密：

  * 预分配已经通过 pattern 兜住了。
  * 实际 setValues 可以一行一次丢进去，PETSc 扛得住。

**验收**

* 写测试 `tests/test_build_transport_system_petsc_native_matches_numpy.py`：

  * 用很小的网格（Nl=1, Ng=3 或 5）。
  * 调 numpy 版得到 `A_np, b_np`。
  * 调 native 版得到 `A_petsc, b_petsc`。
  * 用 `A_petsc.getValues(range(N), range(N))` 拿一整块 dense 回来，比较和 `A_np` 的 max diff 在某个阈值内（纯装配应该是 0 或极小浮点误差）。
  * 同理比较 `b`。

到这一步为止，“桥接 dense” 这条线在 **transport system** 上就已经可以弃用了。

---

## S3.5：把 native 装配接入 linear solver & SNES 的 A≈P 模式

这一步是把新玩具串起来用，避免“写完只躺在那儿”。

### 线性求解器链路

* 在 `timestepper._assemble_transport_system_step12` 中：

  * 当 `backend="petsc" & assembly_mode="native_aij"` 时，传给 `solve_linear_system(...)` 的就是 Mat/Vec，而不是 numpy。
* `solver_linear.solve_linear_system(...)` 中已经有类型检查：

  * 如果 A 是 numpy，就调用 `numpy_dense_to_petsc_aij` 转。
  * 如果 A 本身就是 PETSc.Mat，就直接扔给 `petsc_linear.solve_linear_system_petsc`。
  * 所以你只要确保 `build_transport_system_petsc_native` 返回的是 PETSc.Mat / Vec，后面就不用改。

### SNES 中的 “mfpc_aijA” 模式（可选）

`build_precond_aij.py` 现在还是 dense→AIJ 桥接。如果你还想继续用 `jacobian_mode="mfpc_aijA"`，可以顺手把它也升级成用 native 装配：

* 在 `build_precond_mat_aij_from_A(ctx, ...)` 里：

  * 如果 assembly_mode == "native_aij":

    * 直接调用 `build_transport_system_petsc_native(...)` 拿一份 A_petsc，当作 P。
    * 或者用 pattern + transport 核心装配一个“稀疏的 A(u)” 当 PC。
  * `jacobian_mode="mfpc_sparse_fd"` 不受影响，继续用你已经写好的 sparse FD 路径。

不想折腾的话，干脆把 `mfpc_aijA` 标记成 “只在小问题调试用”，大规模跑统一用 `mfpc_sparse_fd` 就行。

**验收**

* 线性 backend equivalence 那几个 test，用

  * `backend=scipy` VS `backend=petsc + assembly_mode=native_aij`
    结果保持一致。
* SNES 在 `jacobian_mode=mfpc_sparse_fd` 下不受影响；`mfpc_aijA` 要么：

  * 也走 native 装配，或
  * 明确写在配置/文档里“只用于小规模 debug”。

---

## S3.6：写两组“验收型”测试 & 简单基准

最后给 Stage 3 自己设一个“毕业线”，不然你到时候又会怀疑是不是做了无用功。

### 新增测试

1. **装配一致性测试**

   * `tests/test_transport_assembly_petsc_native_vs_numpy.py`

     * 小网格、多种 case（是否开启 Tl、Yl、多组分）。
     * 比较 A、b 完全一致（或在 1e-12 以内）。

2. **性能/nnz 粗测**

   * `tests/test_transport_assembly_petsc_native_nnz_sane.py`

     * 中等 N（例如 N≈1000–2000）。
     * 检查：

       * `A.getInfo()["nz_used"] / N` 在合理范围（几十以内，不是上千）。
       * 运行时间明显优于 dense 桥接版（至少不会更慢）。

### 简单基准（不用太仪式）

在 `bench/` 或随便一个脚本里：

* 固定 case，扫 N（Ng 从 20 → 200 → 500）：

  * `assembly_mode=bridge_dense`
  * `assembly_mode=native_aij`
* 记录：装配时间 + 内存峰值（粗略看 top / 日志）。

**Stage 3 验收标准（我替你定个门槛）**

* 对于 Ng ≈ O(10^2–10^3)：

  * native 装配的 **内存** 增长明显更温和（接近 O(N)，不是 O(N²)）。
  * **装配时间** 不比 bridge_dense 慢，通常会更快。
* 所有线性等价性测试仍然通过：物理 & 数值结果一致。

---

## 小结一下你接下来要干的事

按顺序执行的话，你 Stage 3 的 TODO 清单大概是：

1. **加 `assembly_mode` 开关**，把 bridge 路径稳定下来。
2. 用 `JacobianPattern` 写一个 **统一的 PETSc 预分配 helper**。
3. 实现 `create_empty_transport_mat_vec_petsc(pattern, comm)`。
4. 把 `build_transport_system_petsc_native` 写出来（哪怕先直接 copy numpy 装配代码）。
5. 把 native 装配接到 `timestepper` → `solver_linear` 链路上，确保 linear backend equivalence 继续通过。
6. （可选）让 SNES 的 `mfpc_aijA` 也用 native A 作为 PC。
7. 写两三个 test + 一个小 bench，给 Stage 3 画上“毕业章”。

做完这一轮，你的线性装配端就彻底脱离 dense 玩具了，后面 Stage 4 再去搞 FieldSplit/并行结构预条件器，不会再被 O(N²) 矩阵拖后腿。













## Stage 4：结构化预条件器（FieldSplit / Schur / ASM）上线

**目标**：把“物理块结构”告诉 PETSc，别让它拿一坨变量瞎 GMRES。

你的未知量本质是分块的（典型：Tg / Yg / Tl / Yl / Ts / mpp / Rd）。万级下强烈建议：

* **推荐路线**

  * `-pc_type fieldsplit`
  * block 定义按 layout 分段（你 layout 已经是按 residual block 排列的，这点很舒服）
  * 可选 Schur complement（尤其界面变量耦合强时）

* **交付物**

  * `layout` 提供每个 block 的 index set（IS）：

    * `layout.build_is_petsc(comm) -> dict[str, PETSc.IS]`
  * `petsc_linear/petsc_nonlinear` 里支持把这些 IS 传给 PCFieldSplit

* **验收**

  * 万级未知量下 KSP 迭代次数稳定（不会随网格翻倍就爆炸）
  * SNES 迭代次数稳定

---

## Stage 5：并行化（MPI 分布式 Vec/Mat），从“能跑”到“能扩展”

**目标**：真正进入你说的“并行隐式非线性”。这阶段的关键不是 SNES，而是：**数据分布 + ghost + 本地装配**。

### 5.1 引入 DM（推荐 DMDA，1D 简洁）

* 用 DMDA 管理 1D 网格分块、ghost cell、局部向量
* unknown layout 要支持 local/global mapping（你现在布局是 global contiguous，后面要分布）

### 5.2 装配转为“本地贡献”

* `FormFunctionLocal()`（或你自己：local u -> local residual，再 scatter）

* Mat 用 `setValuesLocal` 或 `MatSetValuesStencil`（DMDA 最舒服）

* 预分配要按局部 stencil 来

* **交付物**

  * `parallel/dmda_manager.py`：创建 DMDA、local/global scatter
  * `layout`：提供局部索引映射（local dof <-> global dof）
  * `assembly_petsc_local.py`：本地装配

* **验收**

  * `mpiexec -n 2/4/8` 结果一致（误差在浮点容许内）
  * 并行效率别太难看（至少不会比串行更慢，先别指望线性加速）

---

## Stage 6：面向“万级未知量”的稳健性工程

**目标**：让它能长期跑，不是跑两步就爆。你会开始关心“收敛失败怎么办、dt 怎么调、Jacobian 什么时候更新、失败如何回退”。

* **必做项**

  * SNES line search/trust region 配置可切换
  * Jacobian/PC lag 策略默认启用
  * 失败回退策略（减小 dt、重置初值、切换 KSP/PC）
  * 关键量的物理约束保护（Y clamp、T bounds、质量分数闭合等）
* **验收**

  * 给定一组中等规模 case（比如 1e4 unknown），能稳定推进 N 步（比如几十到几百步）不崩

---

## Stage 7：性能与可扩展性验收（真正的“工程交付”）

**目标**：量化你是否达到了“万级、并行、隐式非线性”的目标，而不是凭感觉。

* **交付物**

  * `bench/`：基准脚本 + 记录
  * 指标：

    * 每步 wall time
    * SNES iter / KSP iter
    * F(u) 调用次数
    * 内存占用
    * strong/weak scaling 简单报告
* **验收**

  * 万级 unknown：KSP 迭代数不爆炸，wall time 可接受
  * MPI 扩到 4–16 rank 有收益（哪怕不线性）

---

## 最后给你一个“现实的默认配置模板”（万级起步）

等你到 Stage 4/5 之后，通常会是类似这种组合：

* SNES：`newtonls + bt`
* KSP：`fgmres`（更适合非线性/变预条件器）
* PC：`fieldsplit` 或 `asm`（并行下常用）
* lag：`-snes_lag_preconditioner 5 -snes_lag_jacobian 5`

你以后要做的是：**让这些都能通过 cfg/yaml 无痛切换**，而不是改代码。

---

### 你现在处于哪？

你已经完成到 **Stage 0**，并且线性链路可切换、对比测试已建立。
下一步自然就是 **Stage 1（串行 SNES 跑通）**，然后尽快跳到 **Stage 2/4（预条件器）**，否则“万级未知量”会用残差评估次数把你按在地上摩擦。

如果你愿意继续讨论 B.4，我会按你当前的代码结构（`residual_global.py + layout + state pack/unpack + props/eq`）给一份“最小改动 SNES 接入方案”，并且把 Stage 1 的对比测试也一起补上（SciPy 全局非线性 vs PETSc SNES）。











---

## 阶段 C：加入外置化学（Cantera）并升级为自点火仿真

在物理与数值框架稳定后，最后一个大模块是 **气相化学**，配合 Step 12 之后的扩展，形成完整的 droplet autoignition 代码。

这里只给一个高层工作路线（具体 Step 编号可以在以后细化成 13+）。

### C.1 Chemistry 封装模块

1. 新建 `chemistry/gas_reaction.py`：
   - 使用 Cantera 机制（已在 `cfg.paths.gas_mech` 中配置）；
   - 接收 `Tg[i]`, `Yg[:, i]`, `P`；
   - 输出：
     - `omega_k`（反应源项，kg/(m^3·s) 或 mol/(m^3·s)）；
     - `q_dot`（化学热释放率）。
2. 提供：
   - **单 cell ODE 右端项**函数；
   - 批量 cell 调用接口（可并行）。

### C.2 时间拆分 / 耦合策略

1. 实现 Strang 拆分骨架：
   - 半步化学 → 一步传输 → 半步化学；
   - 或 simpler：先传输后化学（第一版）。
2. 在 timestepper 中扩展：
   - `advance_transport_only(...)`（复用 Step 12）；
   - `advance_chemistry_only(...)`（Cantera ODE 或 CVODE）。

### C.3 化学–界面耦合与点火诊断

1. 在界面附近对 `Yg`、`Tg` 的快速变化进行采样；
2. 定义点火判据（dT/dt、OH 峰值等）；
3. 增加 Diagnostics：
   - 点火延迟时间；
   - 最大温度、物种峰值等。

---

## 阶段目标小结

- **阶段 A（Windows + SciPy，至 Step 12）**  
  - 多组分液滴，无化学源项；  
  - 全部物理控制（气相能量 + 多组分扩散 + Stefan 对流 + 液相导热 + 界面平衡 + 半径演化）；  
  - 单步推进 / 多步仿
\\\





