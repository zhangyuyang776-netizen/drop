content = r"""# 多组分液滴无化学数值框架工作路线（Windows-SciPy → Linux-PETSc → 加化学）

> 目标：在 **Windows + SciPy** 环境下完成 `Step 0 ~ Step 12` 的全部工作，跑通一个“多组分液滴 + 全部物理控制（无化学源项）”的测试算例；  
> 后续在 **Linux + PETSc** 环境中无缝迁移求解器后端，再接入气相化学，演化为完整自点火数值仿真框架。

本路线基于项目中的三份说明文档：

- `Droplet_Transport_Framework_NoChemistry.md`
- `NewProject_Guide_NoChem_PETSc.md`
- `工作路线.md`

并在其基础上增加：

- **Windows 阶段：线性系统用 SciPy 求解**，PETSc 仅保留接口与占位；
- **Linux 阶段：切换到 petsc4py + PETSc KSP**；
- **第三阶段：接入外置化学（Cantera）与时间拆分**。

---

## 阶段 A：Windows + SciPy（目标：完成 Step 0 ~ Step 12）

### A.0 总体约束（沿用原始规范）

在 Windows 阶段，仍然严格遵守原始三条“不可违反的规范”：

1. **索引只从 `UnknownLayout` 来**  
2. **物性只在 `Props`**  
3. **组装只写 `A, b`，不直接改 `State`**

额外新增一条：

4. **线性求解器后端抽象**  
   - Step 0~12 期间：**默认后端 = SciPy**（`scipy.sparse` + `scipy.sparse.linalg`）  
   - PETSc 后端只保留接口 / stub，不在 Windows 上强求可运行。

---

### A.1 Step 0：仓库骨架与配置（Windows 版）

**目标：**  
保持原始 Step 0 要求不变，只在 `README` / `cases` 中额外标注 Windows + SciPy 使用方式。

**具体工作：**

1. 按 `NewProject_Guide_NoChem_PETSc.md` 建立基础目录：
   - `core/`, `properties/`, `physics/`, `assembly/`, `solvers/`, `cases/`, `tests/`, `scripts/` 等。
2. 创建/更新 `cases/case_001.yaml`：
   - 物种列表：多组分气/液；
   - 网格设置（Nl, Ng, r_c, r_f 等）；
   - 时间步 `dt`；
   - 求解器选项中增加：
     - `solver.backend: "scipy"`（Windows 阶段默认）
     - `solver.backend: "petsc"` （预留，将来 Linux 使用）。
3. `README.md` 中明确写出两条开发阶段说明：
   - Windows 阶段：**只要求 SciPy 求解器跑通 Step 12**；
   - PETSc 相关模块（`petsc_ksp.py` 等）视为 **后续 Linux 阶段工作**。

---

### A.2 Step 1：`core/types.py`（立法：字段/shape/单位）

**目标：**  
定义全局数据结构，为后续所有模块提供统一接口，完全与求解器后端无关。

**主要内容：**

- `CaseConfig / Grid1D / State / Props / Diagnostics` dataclass：
  - `State`：`Tg`, `Yg`, `Tl`, `Yl`, `Ts`, `mpp`/`m_evap`, `Rd` 等；
  - `Grid1D`：`Nl`, `Ng`, `Nc`, `r_c`, `r_f`, `V_c`, `A_f`, `liq_slice`, `gas_slice`；
  - `Props`：`rho_g`, `cp_g`, `k_g`, `D_g`, `rho_l`, `cp_l`, `k_l`, `D_l`。
- 提供基本检查函数：
  - `check_sumY(state)`；
  - `check_nonneg(state)`；
  - `Props.validate_shapes(grid, Ns_g, Ns_l)`。

> 和原始工作路线一样，这一步完全不涉及 SciPy / PETSc，后端对它透明。

---

### A.3 Step 2：`core/layout.py`（立法：向量打包）

**目标：**  
统一全局未知量在向量中的布局，为以后任何线性/非线性求解器提供一致的索引。

**主要内容：**

- `UnknownLayout`：
  - `n_dof()`；
  - `has_block("Tg")` / `has_block("Yg")` 等；
  - `idx_Tg(i_g)` / `idx_Tl(i_l)` / `idx_Yg(k, i_g)` 等。
- 提供：
  - `pack_state_to_vec(state, layout) -> np.ndarray`（SciPy 阶段用得上）；
  - 预留 `pack_state_to_petsc_vec(...)` / `unpack_...` 的占位接口（Linux 阶段实现）。

Windows 阶段重点：**先保证 numpy 向量打包/解包完全正确**，测试由 `pytest` + 纯 numpy 完成，不需要 petsc4py。

---

### A.4 Step 3：`core/grid.py`（立法：几何与离散）

**目标：**  
构造球对称 1D 网格（液相 + 气相），并明确：

- `liq_slice`, `gas_slice`；
- `iface_f`（界面所在的 face index）；
- `dr_c`, `dr_f` 等派生量（如果需要）。

**Windows 阶段要求：**

- 保证 `Grid1D` 与 Step 6 的离散 stencil 一致；
- 提供用于测试的小网格构造函数（例如 `make_test_grid_scalar_diffusion()`），让 SciPy 测试可以直接复用。

---

### A.5 Step 4：`properties/equilibrium.py`（界面平衡输出格式）

**目标：**  
定义界面平衡计算的**接口与数据结构**，具体实现可以先留最简单版本：

- 输入：`State`, `Props`, `CaseConfig`，以及 `interface` 相关参数；
- 输出：一个 `EquilibriumResult` / dict，至少包含：
  - `psat_l`（来自 liquid）；
  - `Yg_sat` / `Xg_sat`（界面饱和气相组成）；
  - 将来可扩展 `mpp` 相关量。

**在 Step 12 之前的要求：**

- 可以只实现**无化学、物性驱动**的平衡构型（你已在 `interface` 相关讨论中定过路线）；
- 确保接口稳定，为 Step 11 接入 `Ts/m''/Rd` 时不需要大改。

---

### A.6 Step 5：`properties/gas.py` + `properties/liquid.py`（物性实现）

**目标：**  
使用 Cantera + CoolProp 计算气/液相物性，输出填满 `Props` 的字段。

- `gas.py`：
  - 使用 `ct.Solution`，输入 `Tg[i], Yg[:, i]`；
  - 输出 `rho_g[i], cp_g[i], k_g[i], D_g[:, i], h_g[i], h_gk[:, i]`；
  - **不再做物种映射/归一化**，测试已确认。
- `liquid.py`：
  - 使用 CoolProp 单组分/多组分，输入 `Tl[i], Yl[:, i]`；
  - 输出 `rho_l[i], cp_l[i], k_l[i]`；
  - 额外输出 `psat_l[j], hvap_l[j]` 供界面使用。

**新增：`properties/aggregator.py`**

- `build_props_from_state(cfg, grid, state, gas_model, liq_model) -> (Props, extras)`
- extras 中保留：
  - `gas: {"h_g", "h_gk"}`；
  - `liquid: {"psat_l", "hvap_l"}`。

这些模块与后端无关，Windows + Linux 通用。  
你已经完成 gas/liquid + aggregator 的单元测试，这一步可以视为 **已完成**。

---

### A.7 Step 6：`assembly/build_system.py`（标量扩散最小闭环）+ SciPy 后端

原始 Step 6：  
> “assembly 的‘最小闭环’先跑：标量扩散（无界面、无对流）”

现在在 Windows 阶段，把它拆成两层：

1. **装配层（与后端无关）**  
   - 函数原型可以保持为：

     ```python
     def build_transport_system(
         cfg, grid, layout, state_old, props, dt
     ) -> tuple[A_like, b_like]:
         ...
     ```

     其中 `A_like` / `b_like` 可以是：
     - 纯 numpy dense（初始版本最简单）；
     - 或者 `scipy.sparse` CSR 矩阵 + numpy 向量。

   - 离散内容：仅 Tg 扩散（v = 0），theta-scheme（先固定 theta=1.0），
     - 内边界：r = 0 对称（Neumann）；
     - 外边界：Dirichlet，T = T_inf。
2. **SciPy 求解层（Windows 阶段默认）**
   - 新建 `solvers/scipy_linear.py`：

     ```python
     from scipy.sparse import csr_matrix
     from scipy.sparse.linalg import spsolve

     def solve_scalar_diffusion(A, b, cfg) -> np.ndarray:
         A_csr = csr_matrix(A)   # 如果还不是 CSR
         x = spsolve(A_csr, b)
         return x
     ```

   - 写集成测试：
     - 用简单网格 + 已知初始 Tg；
     - 调用 `build_props_from_state → build_transport_system → solve_scalar_diffusion`；
     - 检查外边界满足 T_inf，内部温度向 T_inf 方向扩散。

> PETSc 版本（`build_transport_system_petsc` + `solvers/petsc_ksp.py`）在 Windows 阶段只需要保留接口和 stub，不要求能 import petsc4py。

---

### A.8 Step 7：`physics/flux_gas.py`（通用导热/扩散 stencil）

**目标：**  
从“专用 Tg 扩散离散”升级为可复用的**通用通量模块**。

**工作内容：**

1. 编写 `compute_gas_diffusive_flux_T(...)`：
   - 输入：`grid`, `Props`, `Tg`；
   - 输出：每个 face 上的导热通量 `q_cond[f]`；
   - 内、外边界分别处理：Neumann + Dirichlet。
2. 为将来的 `Yg` 制定接口（但可以不实现）：
   - 预留 `compute_gas_diffusive_flux_Y(...)` 函数签名。

**在 Windows + SciPy 阶段：**

- Step 6 的 `build_transport_system` 可以先不完全重写为“flux-driven”，但建议逐步调整：
  - 面通量统一由 `flux_gas` 计算；
  - 系数矩阵由 flux 转换为系数；
  - 便于以后统一 energy / species / 多方程耦合。

---

### A.9 Step 8：`physics/stefan_velocity.py` + 对流离散（气相）

**目标：**  
在气相能量方程中加入 **Stefan 速度驱动的对流项**：  
\( \partial_t (\rho h) + \nabla \cdot (\rho u h - k \nabla T) = \dots \)

**工作内容：**

1. `physics/stefan_velocity.py`：
   - 输入：界面蒸发通量 `m''`（后续 Step 11 提供）、局部密度；
   - 输出：气相径向速度场 `u_g(r)`；
   - 初始版本可以采用文献中的简化解析解。
2. 对流通量离散：
   - 新增 `physics/flux_convective.py`（或并入 `flux_gas`）：
     - Upwind / QUICK 等一阶/二阶格式；
     - 内边界 / 外边界处理。

3. 更新 `build_transport_system`：
   - 在 diagonal 和 neighbor 系数中加入对流贡献；
   - 仍然调用 SciPy 求解。

---

### A.10 Step 9：气相多组分 `Yg`（先不加界面）

**目标：**  
在气相加入多组分扩散方程（暂时不与界面耦合，只做“单域多组分传输”）。

**工作内容：**

1. 为 `Yg[k, i]` 构造离散方程：
   - 仅含扩散 + 对流，对每个物种写一套方程；
   - 先不做跨物种耦合（可以采用混合平均扩散系数）。
2. 在 `layout` 中给 `Yg` 分配独立 block：
   - `idx_Yg(k, i)`。
3. 在 `build_transport_system` 中：
   - 扩展为“block 对角矩阵” 或 “统一向量打包”；
   - SciPy 阶段可以先对每个物种独立解（多次调用 `spsolve`），再升级为统一大系统。

---

### A.11 Step 10：液相导热 `Tl`（不含界面耦合）

**目标：**  
在液相内部建立导热方程，先假设界面温度已知或固定（例如等于初始 Ts），**不耦合 m''**。

**工作内容：**

1. 定义液相导热通量 `q_cond_l` 模块；
2. 为液相构造线性系统（可单独一个 `build_liquid_T_system`）；
3. 仍由 SciPy 解，测试：
   - 单独液相导热问题；
   - 简单稳态验证。

---

### A.12 Step 11：`physics/interface_bc.py` + `physics/radius_eq.py`（Ts/m''/Rd）

**目标：**  
将界面温度 `Ts`、蒸发通量 `m''`、液滴半径 `Rd` 作为未知或半隐式更新量，耦合气/液两侧传热与质量传输。

**工作内容：**

1. `interface_bc.py`：
   - 利用 `Props` + `equilibrium` + `liquid` extras：
     - `psat_l`, `hvap_l`, `h_gk`, `rho_g`, `cp_g`, `k_g`, 以及液相物性；
   - 在界面施加能量平衡：
     - `q_g + q_l + m'' h_vap = 0` 类似形式；
   - 施加物质平衡 / 饱和条件：
     - `Yg_sat`, `psat_l` 的使用；
   - 输出：更新 Ts（或对 Ts 的非线性方程残差，留给后续 Newton 阶段）。
2. `radius_eq.py`：
   - 根据 `m''`（总蒸发率）更新液滴半径：
     - 最简单：`dRd/dt = - m'' / (rho_l)` 一类近似；
   - Windows 阶段可以先做显式更新测试。

3. 将界面条件纳入时间推进：
   - 在 Step 12 的 timestepper 中，以“先更新界面标量，再推进域内传输”的方式挂接；
   - 仍使用 SciPy 求解域内传输方程。

---

### A.13 Step 12：整合 `timestepper`（单步推进 + 输出 + 失败诊断）

**目标：**  
在 Windows + SciPy 环境下，完成一个**无化学的多组分液滴测试算例**：

- 完整物理包含：
  - 气相能量 + 多组分扩散 + Stefan 对流；
  - 液相导热；
  - 界面平衡 + Ts + m'' + Rd 演化；
- 时间推进：
  - 制作 `timestepper/single_step.py`：
    - `props = build_props_from_state(...)`
    - `equil = compute_equilibrium(...)`
    - `Ts, m'', Rd = update_interface(...)`
    - `A, b = build_transport_system(...)`（气/液/多组分）
    - `x = solve_linear_system_scipy(A, b, cfg)`
    - `state_new = unpack/update_from_solution(x, layout, state_old)`
  - 制作 `driver/run_case.py`：
    - `for n in range(Nsteps):` 调一个 single_step；
    - 定期输出 `Diagnostics` 与空间场数据。
- 测试算例：
  - 一个多组分液滴（例如 NC12 + PMH 混合）；
  - 在给定 T_inf / P_inf / 远场组分下，跑一段时间，检查：
    - 液滴半径先缓慢变化；
    - Ts、Tg、Yg 场演化正常；
    - 无 NaN/inf，质量/能量收支方向合理。

**到此为止：Windows 阶段目标完成。**

---

## 阶段 B：迁移到 Linux + PETSc（保持物理不变）

Windows 阶段完成 Step 12 后，代码已具备：

- 完整的**无化学物理模型**；
- 清晰的接口分层（Grid/State/Props/Layout/Assembly/Solver）。

下一阶段只做 **后端迁移** 和 **性能升级**，不改物理。

### B.1 在 Linux 上建立开发环境

1. 使用 WSL2 或直接在 Linux 服务器上：
   - 安装 `mambaforge` / `conda`；
   - 创建环境：
     ```bash
     mamba create -n droplet python=3.11
     mamba install -c conda-forge numpy scipy matplotlib cantera coolprop petsc petsc4py
     ```
2. 将仓库 clone 到 Linux 环境；
3. 运行原有的纯 SciPy 测试，确认物理模块行为与 Windows 一致。

### B.2 PETSc 后端接入

1. 编写 `solvers/petsc_ksp.py`：
   - 提供统一接口：
     ```python
     def solve_linear_system_petsc(A_petsc: PETSc.Mat, b_petsc: PETSc.Vec, cfg) -> PETSc.Vec:
         ...
     ```
   - 根据 `cfg.solver` 选择 KSP 类型（cg / gmres），预条件器（jacobi / ilu）、容差等。
2. 为 `build_system` 提供 PETSc 版本（如果未实现）：
   - `build_transport_system_petsc(...) -> (PETSc.Mat, PETSc.Vec)`；
   - 复用 Windows 阶段的 numpy 版 stencil。
3. 写对比测试：
   - 同一物理场景下，比较：
     - SciPy 求解器与 PETSc 求解器得到的解（差异 < 容许误差）；
     - 运行时间与迭代次数。

### B.3 清理“后端分支”

1. 在一个统一的 `solvers/driver.py` 中：
   - 根据 `cfg.solver.backend` 选择 SciPy / PETSc 后端；
   - Windows 上仍可以选择 SciPy；
   - Linux 上可以默认 PETSc。
2. 保留原有 SciPy 版作为“调试模式”：
   - 小规模问题时，SciPy + numpy 更易调试；
   - 大规模 / HPC 场景，切换到 PETSc。

---

## 阶段 C：加入外置化学（Cantera）并升级为自点火仿真

在物理与数值框架稳定后，最后一个大模块是 **气相化学**，配合 Step 12 之后的扩展，形成完整的 droplet autoignition 代码。

这里只给一个高层工作路线（具体 Step 编号可以在以后细化成 13+）。

### C.1 Chemistry 封装模块

1. 新建 `chemistry/gas_reaction.py`：
   - 使用 Cantera 机制（已在 `cfg.paths.gas_mech` 中配置）；
   - 接收 `Tg[i]`, `Yg[:, i]`, `P`；
   - 输出：
     - `omega_k`（反应源项，kg/(m^3·s) 或 mol/(m^3·s)）；
     - `q_dot`（化学热释放率）。
2. 提供：
   - **单 cell ODE 右端项**函数；
   - 批量 cell 调用接口（可并行）。

### C.2 时间拆分 / 耦合策略

1. 实现 Strang 拆分骨架：
   - 半步化学 → 一步传输 → 半步化学；
   - 或 simpler：先传输后化学（第一版）。
2. 在 timestepper 中扩展：
   - `advance_transport_only(...)`（复用 Step 12）；
   - `advance_chemistry_only(...)`（Cantera ODE 或 CVODE）。

### C.3 化学–界面耦合与点火诊断

1. 在界面附近对 `Yg`、`Tg` 的快速变化进行采样；
2. 定义点火判据（dT/dt、OH 峰值等）；
3. 增加 Diagnostics：
   - 点火延迟时间；
   - 最大温度、物种峰值等。

---

## 阶段目标小结

- **阶段 A（Windows + SciPy，至 Step 12）**  
  - 多组分液滴，无化学源项；  
  - 全部物理控制（气相能量 + 多组分扩散 + Stefan 对流 + 液相导热 + 界面平衡 + 半径演化）；  
  - 单步推进 / 多步仿
\\\


可以进 Step 8 了，是的，小朋友要开始玩对流项了。
先别急着改一大堆东西，按块拆一下，不然你又会怀疑“到底是 flux 的锅还是 assembly 的锅”。

下面是一个**精简但完整的 Step 8 工作路线**，分：新增模块 → 修改模块 → 测试内容。

---

## 一、Step 8 的目标再确认

在当前的 Windows + SciPy 流程里，把这条链路加上对流项：

> cfg + grid + state + props
> → **Stefan 速度场 u_g(r)**
> → **对流通量 F_conv**
> → **build_system_SciPy 中的能量方程：扩散 + 对流**
> → SciPy 线性解
> → 新的 `State.Tg_new`

不碰化学，不碰界面耦合，只是在气相能量方程里加一条“被 Stefan 速度驱动的对流项”。

---

## 二、新增模块 1：`physics/stefan_velocity.py`

### 1. 功能定位

给你一个界面蒸发通量 (m'')（state.mpp）和气相密度场 rho_g，算出气相径向速度场 (u_g(r))。

用的是教科书式的简化解析：
在球对称稳态蒸发下，有

[
\rho_g(r) , u_g(r) , r^2 = m'' , R_d^2
]

约定沿 (+e_r) 方向为正，`mpp > 0` 表示蒸发、气体向外流出（和你 `conventions.evap_sign` 一致）。

### 2. 推荐接口设计

文件：`physics/stefan_velocity.py`

核心函数：

```python
def compute_stefan_velocity_gas(
    cfg: CaseConfig,
    grid: Grid1D,
    props: Props,
    state: State,
) -> np.ndarray:
    """
    返回 u_g at gas cell centers, shape = (Ng,).

    Contract:
    - 使用 conventions: radial_normal='+er', flux_sign='outward_positive', evap_sign='mpp>0 => evaporation'。
    - 用 state.mpp (kg/m^2/s) 和 state.Rd (m) + props.rho_g + grid.r_c 构造 u_g。
    """
```

### 3. 计算细节

* `Ng = grid.Ng`

* `gas_start = grid.gas_slice.start`

* 对每个气相单元 `ig`：

  * `cell_idx = gas_start + ig`
  * 半径 `r = grid.r_c[cell_idx]`（注意是 cell center 的 r，而不是 face）
  * 局部密度 `rho = props.rho_g[ig]`
  * `mpp = state.mpp`，`Rd = state.Rd`
  * 如果 `abs(mpp) < eps`，直接设 `u_g[ig] = 0.0`
  * 否则

    [
    u_g[ig] = \frac{m'' R_d^2}{\rho_g(ig) , r^2}
    ]

* 做一些 sanity check：

  * `r > 0`
  * `rho > 0`
  * `grid.iface_f == grid.Nl` 之类的基本结构假设。

* 只返回 **cell-centered** 速度场 `(Ng,)`，face 上的速度由对流通量模块自己去处理（比如简单平均）。

### 4. 单元测试建议

写到 `tests/test_stefan_velocity.py`：

1. **m'' = 0：**

   * 构造一个简单 grid + props（rho_g 常值），state.mpp = 0
   * `u_g` 全为 0，且 shape = (Ng,)

2. **m'' > 0, rho 常值：**

   * 人工构造：`rho_g = const`，`r_c` 等距（只是方便验公式）

   * 手算：

     [
     u_g(r_i) \propto \frac{1}{r_i^2}
     ]

   * 用 `np.all(np.diff(u_g) < 0)` 检查速度随 r 递减

   * spot-check 若干点：用解析公式算一个期望值，`assert_allclose` 容许 1e-12 之类误差。

3. **非法情况：**

   * 把某个 rho_g 设为负或 0，期待抛出 `ValueError`（至少要防止悄悄算出垃圾）。

---

## 三、新增模块 2：气相对流通量 `flux_convective_gas.py`

你可以叫 `physics/flux_convective.py`，专门存对流通量；你现在 `flux_gas.py` 里只有扩散，别把所有东西搅成一锅。

### 1. 功能定位

给定：

* 网格 `grid`
* 物性 `props`（至少 rho_g, cp_g）
* Stefan 速度场 `u_g(ig)`
* 标量场 `Tg(ig)`（或者将来是 `h_g(ig)`）

求：**气相能量对流通量**，face 上的 (F_{\text{conv},f})，满足“**outward positive**”约定。

能量方程里用的是体积分形式：

[
(\rho c_p V)\frac{T^{n+1}-T^n}{\Delta t} + \sum_f s_f F_{\text{conv},f} - \sum_f s_f q_{\text{cond},f} = 0
]

其中：

* `F_conv,f = (rho u h)_face * A_f`
* 对 Step 8 简化版，可以取 `h ≈ cp * T`，不一定非要用 Cantera 的 `h_g`。

### 2. 推荐接口

```python
def compute_gas_convective_flux_T(
    cfg: CaseConfig,
    grid: Grid1D,
    props: Props,
    u_g: np.ndarray,   # (Ng,)
    Tg: np.ndarray,    # (Ng,)
) -> np.ndarray:
    """
    返回 F_conv_T on faces, shape = (Nc+1,),
    单位大致是 W (能量流率)，符号：outward_positive。
    """
```

### 3. 数值格式（建议：一阶 upwind）

对每个 **气相内部面**（在网格中对应 cell_idx = gas_start+ig+1）：

1. 定位左右单元：

   * 左：`ig`, 右：`ig+1`
   * `iL = gas_start + ig`, `iR = gas_start + ig+1`
   * face index `f = iR`（和你在 `flux_gas` 里一致）

2. 面上的物性 & 速度：

   * `rho_face = 0.5 * (rho_g[ig] + rho_g[ig+1])`
   * `cp_face = 0.5 * (cp_g[ig] + cp_g[ig+1])`
   * `u_face = 0.5 * (u_g[ig] + u_g[ig+1])`
   * `A_f = grid.A_f[f]`
   * 质量流率：`m_face = rho_face * u_face * A_f`

3. upwind：

   * 若 `m_face >= 0`（流向外，指向右单元），上风单元是左侧：

     * `T_up = Tg[ig]`
   * 否则上风是右侧：

     * `T_up = Tg[ig+1]`
   * `h_up = cp_face * T_up`

4. 面通量：

   * `F_conv[f] = m_face * h_up`
     这个定义已经隐含了“沿 +er 方向为正”的约定。

**边界：**

* **界面面 `f_if = grid.iface_f`**
  Step 8 先别硬搬真实界面通量，建议：

  * 先做**两种模式**方便以后切换：

    1. **模式 A（Stefan-only 验证）**：在测试里给 `u_g` 手工构造一个速度场，不从 `mpp` 推导；界面 conv flux 直接设 0，这样就不“吃”界面物理，只验证内部对流离散。
       适合现在 Step 8 Windows 小闭环测试。
    2. **模式 B（m'' 驱动）**：等 Step 11 接上 interface 后，把

       [
       F_{\text{conv},f_\text{if}} = m'' h_\text{if}
       ]

       交给 interface 模块来算，这里只接收一个给定的 `F_if`。

  * 现在推荐：**Step 8 先实现模式 A**：`F_conv[f_if] = 0.0`，保留 TODO。

* **外边界面 f_out = Nc：**

  * 对 Stefan 蒸发来说，`u > 0`，流向外侧，所以不会有外界流入，不需要上风来自环境。
  * 建议简单处理：

    * `rho_face = rho_g[-1]`
    * `cp_face = cp_g[-1]`
    * `u_face = u_g[-1]`
    * `A_f = grid.A_f[-1]`
    * `m_face = rho_face * u_face * A_f`
    * `T_up = Tg[-1]`
    * `F_conv[f_out] = m_face * cp_face * T_up`
  * Dirichlet 的 `T_inf` 继续只通过导热（`flux_gas` + build_system）来约束，不用在 conv 这里掺一脚。

### 4. 单元测试建议

写 `tests/test_flux_convective_gas.py`：

1. **简单常系数场：**

   * `Ng=3`，`rho_g=1`，`cp_g=1`，`u_g=1` 常值，`Tg = [1, 2, 3]`
   * 均匀网格，`A_f=1`
   * 手算：

     * face between cell 0 & 1：`m_face = 1`，上风是 cell 0 -> `F = 1*1*1 = 1`
     * face between 1 & 2：上风是 cell 1 -> `F = 1*1*2 = 2`
   * 检查内部 face 的值和 sign 是否正确。

2. **反向速度（u_g<0）：**

   * 同样构造一个 `u_g = -1` 场，检查上风变到右单元。

3. **形状检查：**

   * `F_conv.shape == (Nc+1,)`
   * 非气相区域的 face（比如液相内部）的 F_conv 保持 0（如果你只在 gas faces 填值）。

---

## 四、修改 `build_system_SciPy.py`：扩散 + 对流

### 1. 函数签名调整

在 `build_system_SciPy.py` 中，把主函数改成：

```python
def build_transport_system_scipy(
    cfg: CaseConfig,
    grid: Grid1D,
    layout: UnknownLayout,
    state_old: State,
    props: Props,
    dt: float,
    u_g: Optional[np.ndarray] = None,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Step 6+8: Tg 扩散 + 可选对流 (u_g != None 时)。
    """
```

* 保持 **纯 SciPy**，输出 `A (ndarray or csr)` 和 `b (ndarray)`。
* `u_g is None` 时退化为纯扩散（复用当前 Step 6 的逻辑）。

### 2. 对流项装配方式（建议简单版）

你现在的扩散是直接在 build_system 里用 `k_g` + `r_c` + `A_f` 组 aP / aW / aE。
Step 8 可以先用**一样的风格**组对流项，不用强迫自己立刻“完全 flux 驱动”。

建议做法：

1. 如果传入了 `u_g`：

   * 调用 `compute_gas_convective_flux_T(...)` 得到 `F_conv`（face 上能量通量）。
2. 在循环各个气相单元 `ig` 时：

   * 对每个单元 i，取其左右 faces：`f_L`, `f_R`（和你扩散项里用的同一套索引）

   * 残差中 conv 部分：

     [
     R_i^{\text{conv}} = F_{\text{conv},f_R} - F_{\text{conv},f_L}
     ]

   * 你要把这一项写成对 `T_i`、`T_{i-1}`、`T_{i+1}` 的线性组合。
     因为 `F_conv` 里用的是 upwind，所以：

     * 如果 face `f_R` 是从 i 流向 i+1，则 `F_conv,f_R` 对 `T_i` 有系数，
       如果是从 i+1 流向 i，则对 `T_{i+1}` 有系数。
     * 同理 f_L。

   * 简化版实现可以这样：

     * 在 `compute_gas_convective_flux_T` 中，同时返回：

       * 一个 face 上的 flux 数值 `F_conv[f]`
       * 两个数组 `coeff_L[f]`，`coeff_R[f]`，使得

         [
         F_{\text{conv},f} = coeff_L[f] * T_L + coeff_R[f] * T_R
         ]

       这样在 `build_system_SciPy` 里就非常好装：
       aP/aW/aE 的 conv 部分从这些系数拆出来加到 matrix row 中。

   * 但是这已经有点“工程化”，你如果嫌麻烦，Step 8 可以只做“**弱验证**”：

     * 直接在 build_system 中重新实现 upwind conv（像你扩散那样手搓），先不共享到 flux_convective 里。
     * flux_convective 模块只做单元测试使用，为以后统一改造准备。

   你要的是“小工作路线”，那我建议：

   > 现在 build_system 里的对流项**先手搓一版**，确保 Step 8 流程跑通。
   > 等 Step 9/10 再把扩散 + 对流完全从 flux 模块抽象出来。

---

## 五、Step 8 的测试设计

写一个新的测试文件，比如：`tests/test_step8_scipy_convection.py`。

### 1. 基础 closed-loop 测试：扩散 + 对流

结构类似你 Step 6 的测试 `test_step6_scipy_transport.py`：

1. 构造简单 cfg / grid / state：

   * `Ng=3` 或 4，`Tg = [T_hot, T_mid, T_cold]`，`T_inf = T_cold`
   * `Yg` 只做 dummy N2，保持简单

2. 用 `gas_model + aggregator` 得到 props。

3. 选一个非零 `mpp`，用 `compute_stefan_velocity_gas` 计算 `u_g`。

4. 调用：

   ```python
   A, b = build_transport_system_scipy(cfg, grid, layout, state_old, props, dt, u_g=u_g)
   result = solve_linear_system_scipy(A, b, cfg)
   ```

5. 把解回写到新 `State` 中（`Tg_new`），然后做判据：

   * 端点温度：

     * 最外层 cell 满足 Dirichlet：`abs(Tg_new[-1] - T_inf) < tol`
   * 对流趋势：

     * 例如设置：界面附近更热，`mpp > 0`（向外吹），你期望**内部的温度向外传输更快**：

       * 可以和“纯扩散版本”做对比：

         * 跑一遍 `u_g=None` 的纯扩散，得到 Tg_diff
         * 跑一遍 `u_g!=None` 的扩散+对流，得到 Tg_conv
         * 检查：在靠界面的一两个 cell 中，`Tg_conv` 比 `Tg_diff` 更靠近 outer/inner 端，这个你可以人为指定一个预期趋势（比如温度下降更快或更慢，视你怎么设置初始条件）。

   判据不要再写成“500.00000 == 500.0”那种死板 equality，统一用 `np.allclose`/`assert abs(...) < 1e-5` 级别。

### 2. 只对流、无扩散的 sanity（可选）

为了单独验证对流项的 sign 和 upwind 行为，你可以临时令 `k_g = 0`，只装配对流，看看温度是否按照速度方向迁移，这个可以做一个简单 sanity test，出问题时能快速定位是扩散段错，还是对流段错。

---

## 六、小结：Step 8 需要改 / 新增的东西

**新增文件：**

1. `physics/stefan_velocity.py`

   * `compute_stefan_velocity_gas(...) -> u_g (Ng,)`

2. `physics/flux_convective.py`（或者你起的别名）

   * `compute_gas_convective_flux_T(...) -> F_conv_T (Nc+1,)`
   * / 或 stub + 单元测试，为将来统一 flux 驱动做准备

**修改文件：**

3. `build_system_SciPy.py`

   * 函数签名加 `u_g: Optional[np.ndarray]`
   * 当 `u_g is not None` 时，把对流贡献装入矩阵和右端项
   * 保留 `u_g=None` 时退化为 Step 6 纯扩散逻辑

**测试文件：**

4. `tests/test_stefan_velocity.py`
5. `tests/test_flux_convective_gas.py`
6. `tests/test_step8_scipy_convection.py`（扩散 + 对流闭环）

你先按这个拆法写 / 让 Codex 写代码，写完再拿回来我帮你挑毛病。毕竟你要是一次性全糊在一起，最后连是谁错了都查不清。
