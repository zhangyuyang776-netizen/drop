content = r"""# 多组分液滴无化学数值框架工作路线（Windows-SciPy → Linux-PETSc → 加化学）

> 目标：在 **Windows + SciPy** 环境下完成 `Step 0 ~ Step 12` 的全部工作，跑通一个“多组分液滴 + 全部物理控制（无化学源项）”的测试算例；  
> 后续在 **Linux + PETSc** 环境中无缝迁移求解器后端，再接入气相化学，演化为完整自点火数值仿真框架。

本路线基于项目中的三份说明文档：

- `Droplet_Transport_Framework_NoChemistry.md`
- `NewProject_Guide_NoChem_PETSc.md`
- `工作路线.md`

并在其基础上增加：

- **Windows 阶段：线性系统用 SciPy 求解**，PETSc 仅保留接口与占位；
- **Linux 阶段：切换到 petsc4py + PETSc KSP**；
- **第三阶段：接入外置化学（Cantera）与时间拆分**。

---

## 阶段 A：Windows + SciPy（目标：完成 Step 0 ~ Step 12）

### A.0 总体约束（沿用原始规范）

在 Windows 阶段，仍然严格遵守原始三条“不可违反的规范”：

1. **索引只从 `UnknownLayout` 来**  
2. **物性只在 `Props`**  
3. **组装只写 `A, b`，不直接改 `State`**

额外新增一条：

4. **线性求解器后端抽象**  
   - Step 0~12 期间：**默认后端 = SciPy**（`scipy.sparse` + `scipy.sparse.linalg`）  
   - PETSc 后端只保留接口 / stub，不在 Windows 上强求可运行。

---

### A.1 Step 0：仓库骨架与配置（Windows 版）

**目标：**  
保持原始 Step 0 要求不变，只在 `README` / `cases` 中额外标注 Windows + SciPy 使用方式。

**具体工作：**

1. 按 `NewProject_Guide_NoChem_PETSc.md` 建立基础目录：
   - `core/`, `properties/`, `physics/`, `assembly/`, `solvers/`, `cases/`, `tests/`, `scripts/` 等。
2. 创建/更新 `cases/case_001.yaml`：
   - 物种列表：多组分气/液；
   - 网格设置（Nl, Ng, r_c, r_f 等）；
   - 时间步 `dt`；
   - 求解器选项中增加：
     - `solver.backend: "scipy"`（Windows 阶段默认）
     - `solver.backend: "petsc"` （预留，将来 Linux 使用）。
3. `README.md` 中明确写出两条开发阶段说明：
   - Windows 阶段：**只要求 SciPy 求解器跑通 Step 12**；
   - PETSc 相关模块（`petsc_ksp.py` 等）视为 **后续 Linux 阶段工作**。

---

### A.2 Step 1：`core/types.py`（立法：字段/shape/单位）

**目标：**  
定义全局数据结构，为后续所有模块提供统一接口，完全与求解器后端无关。

**主要内容：**

- `CaseConfig / Grid1D / State / Props / Diagnostics` dataclass：
  - `State`：`Tg`, `Yg`, `Tl`, `Yl`, `Ts`, `mpp`/`m_evap`, `Rd` 等；
  - `Grid1D`：`Nl`, `Ng`, `Nc`, `r_c`, `r_f`, `V_c`, `A_f`, `liq_slice`, `gas_slice`；
  - `Props`：`rho_g`, `cp_g`, `k_g`, `D_g`, `rho_l`, `cp_l`, `k_l`, `D_l`。
- 提供基本检查函数：
  - `check_sumY(state)`；
  - `check_nonneg(state)`；
  - `Props.validate_shapes(grid, Ns_g, Ns_l)`。

> 和原始工作路线一样，这一步完全不涉及 SciPy / PETSc，后端对它透明。

---

### A.3 Step 2：`core/layout.py`（立法：向量打包）

**目标：**  
统一全局未知量在向量中的布局，为以后任何线性/非线性求解器提供一致的索引。

**主要内容：**

- `UnknownLayout`：
  - `n_dof()`；
  - `has_block("Tg")` / `has_block("Yg")` 等；
  - `idx_Tg(i_g)` / `idx_Tl(i_l)` / `idx_Yg(k, i_g)` 等。
- 提供：
  - `pack_state_to_vec(state, layout) -> np.ndarray`（SciPy 阶段用得上）；
  - 预留 `pack_state_to_petsc_vec(...)` / `unpack_...` 的占位接口（Linux 阶段实现）。

Windows 阶段重点：**先保证 numpy 向量打包/解包完全正确**，测试由 `pytest` + 纯 numpy 完成，不需要 petsc4py。

---

### A.4 Step 3：`core/grid.py`（立法：几何与离散）

**目标：**  
构造球对称 1D 网格（液相 + 气相），并明确：

- `liq_slice`, `gas_slice`；
- `iface_f`（界面所在的 face index）；
- `dr_c`, `dr_f` 等派生量（如果需要）。

**Windows 阶段要求：**

- 保证 `Grid1D` 与 Step 6 的离散 stencil 一致；
- 提供用于测试的小网格构造函数（例如 `make_test_grid_scalar_diffusion()`），让 SciPy 测试可以直接复用。

---

### A.5 Step 4：`properties/equilibrium.py`（界面平衡输出格式）

**目标：**  
定义界面平衡计算的**接口与数据结构**，具体实现可以先留最简单版本：

- 输入：`State`, `Props`, `CaseConfig`，以及 `interface` 相关参数；
- 输出：一个 `EquilibriumResult` / dict，至少包含：
  - `psat_l`（来自 liquid）；
  - `Yg_sat` / `Xg_sat`（界面饱和气相组成）；
  - 将来可扩展 `mpp` 相关量。

**在 Step 12 之前的要求：**

- 可以只实现**无化学、物性驱动**的平衡构型（你已在 `interface` 相关讨论中定过路线）；
- 确保接口稳定，为 Step 11 接入 `Ts/m''/Rd` 时不需要大改。

---

### A.6 Step 5：`properties/gas.py` + `properties/liquid.py`（物性实现）

**目标：**  
使用 Cantera + CoolProp 计算气/液相物性，输出填满 `Props` 的字段。

- `gas.py`：
  - 使用 `ct.Solution`，输入 `Tg[i], Yg[:, i]`；
  - 输出 `rho_g[i], cp_g[i], k_g[i], D_g[:, i], h_g[i], h_gk[:, i]`；
  - **不再做物种映射/归一化**，测试已确认。
- `liquid.py`：
  - 使用 CoolProp 单组分/多组分，输入 `Tl[i], Yl[:, i]`；
  - 输出 `rho_l[i], cp_l[i], k_l[i]`；
  - 额外输出 `psat_l[j], hvap_l[j]` 供界面使用。

**新增：`properties/aggregator.py`**

- `build_props_from_state(cfg, grid, state, gas_model, liq_model) -> (Props, extras)`
- extras 中保留：
  - `gas: {"h_g", "h_gk"}`；
  - `liquid: {"psat_l", "hvap_l"}`。

这些模块与后端无关，Windows + Linux 通用。  
你已经完成 gas/liquid + aggregator 的单元测试，这一步可以视为 **已完成**。

---

### A.7 Step 6：`assembly/build_system.py`（标量扩散最小闭环）+ SciPy 后端

原始 Step 6：  
> “assembly 的‘最小闭环’先跑：标量扩散（无界面、无对流）”

现在在 Windows 阶段，把它拆成两层：

1. **装配层（与后端无关）**  
   - 函数原型可以保持为：

     ```python
     def build_transport_system(
         cfg, grid, layout, state_old, props, dt
     ) -> tuple[A_like, b_like]:
         ...
     ```

     其中 `A_like` / `b_like` 可以是：
     - 纯 numpy dense（初始版本最简单）；
     - 或者 `scipy.sparse` CSR 矩阵 + numpy 向量。

   - 离散内容：仅 Tg 扩散（v = 0），theta-scheme（先固定 theta=1.0），
     - 内边界：r = 0 对称（Neumann）；
     - 外边界：Dirichlet，T = T_inf。
2. **SciPy 求解层（Windows 阶段默认）**
   - 新建 `solvers/scipy_linear.py`：

     ```python
     from scipy.sparse import csr_matrix
     from scipy.sparse.linalg import spsolve

     def solve_scalar_diffusion(A, b, cfg) -> np.ndarray:
         A_csr = csr_matrix(A)   # 如果还不是 CSR
         x = spsolve(A_csr, b)
         return x
     ```

   - 写集成测试：
     - 用简单网格 + 已知初始 Tg；
     - 调用 `build_props_from_state → build_transport_system → solve_scalar_diffusion`；
     - 检查外边界满足 T_inf，内部温度向 T_inf 方向扩散。

> PETSc 版本（`build_transport_system_petsc` + `solvers/petsc_ksp.py`）在 Windows 阶段只需要保留接口和 stub，不要求能 import petsc4py。

---

### A.8 Step 7：`physics/flux_gas.py`（通用导热/扩散 stencil）

**目标：**  
从“专用 Tg 扩散离散”升级为可复用的**通用通量模块**。

**工作内容：**

1. 编写 `compute_gas_diffusive_flux_T(...)`：
   - 输入：`grid`, `Props`, `Tg`；
   - 输出：每个 face 上的导热通量 `q_cond[f]`；
   - 内、外边界分别处理：Neumann + Dirichlet。
2. 为将来的 `Yg` 制定接口（但可以不实现）：
   - 预留 `compute_gas_diffusive_flux_Y(...)` 函数签名。

**在 Windows + SciPy 阶段：**

- Step 6 的 `build_transport_system` 可以先不完全重写为“flux-driven”，但建议逐步调整：
  - 面通量统一由 `flux_gas` 计算；
  - 系数矩阵由 flux 转换为系数；
  - 便于以后统一 energy / species / 多方程耦合。

---

### A.9 Step 8：`physics/stefan_velocity.py` + 对流离散（气相）

**目标：**  
在气相能量方程中加入 **Stefan 速度驱动的对流项**：  
\( \partial_t (\rho h) + \nabla \cdot (\rho u h - k \nabla T) = \dots \)

**工作内容：**

1. `physics/stefan_velocity.py`：
   - 输入：界面蒸发通量 `m''`（后续 Step 11 提供）、局部密度；
   - 输出：气相径向速度场 `u_g(r)`；
   - 初始版本可以采用文献中的简化解析解。
2. 对流通量离散：
   - 新增 `physics/flux_convective.py`（或并入 `flux_gas`）：
     - Upwind / QUICK 等一阶/二阶格式；
     - 内边界 / 外边界处理。

3. 更新 `build_transport_system`：
   - 在 diagonal 和 neighbor 系数中加入对流贡献；
   - 仍然调用 SciPy 求解。

---

### A.10 Step 9：气相多组分 `Yg`（先不加界面）

**目标：**  
在气相加入多组分扩散方程（暂时不与界面耦合，只做“单域多组分传输”）。

**工作内容：**

1. 为 `Yg[k, i]` 构造离散方程：
   - 仅含扩散 + 对流，对每个物种写一套方程；
   - 先不做跨物种耦合（可以采用混合平均扩散系数）。
2. 在 `layout` 中给 `Yg` 分配独立 block：
   - `idx_Yg(k, i)`。
3. 在 `build_transport_system` 中：
   - 扩展为“block 对角矩阵” 或 “统一向量打包”；
   - SciPy 阶段可以先对每个物种独立解（多次调用 `spsolve`），再升级为统一大系统。

---

### A.11 Step 10：液相导热 `Tl`（不含界面耦合）

**目标：**  
在液相内部建立导热方程，先假设界面温度已知或固定（例如等于初始 Ts），**不耦合 m''**。

**工作内容：**

1. 定义液相导热通量 `q_cond_l` 模块；
2. 为液相构造线性系统（可单独一个 `build_liquid_T_system`）；
3. 仍由 SciPy 解，测试：
   - 单独液相导热问题；
   - 简单稳态验证。

---

### A.12 Step 11：`physics/interface_bc.py` + `physics/radius_eq.py`（Ts/m''/Rd）

**目标：**  
将界面温度 `Ts`、蒸发通量 `m''`、液滴半径 `Rd` 作为未知或半隐式更新量，耦合气/液两侧传热与质量传输。

**工作内容：**

1. `interface_bc.py`：
   - 利用 `Props` + `equilibrium` + `liquid` extras：
     - `psat_l`, `hvap_l`, `h_gk`, `rho_g`, `cp_g`, `k_g`, 以及液相物性；
   - 在界面施加能量平衡：
     - `q_g + q_l + m'' h_vap = 0` 类似形式；
   - 施加物质平衡 / 饱和条件：
     - `Yg_sat`, `psat_l` 的使用；
   - 输出：更新 Ts（或对 Ts 的非线性方程残差，留给后续 Newton 阶段）。
2. `radius_eq.py`：
   - 根据 `m''`（总蒸发率）更新液滴半径：
     - 最简单：`dRd/dt = - m'' / (rho_l)` 一类近似；
   - Windows 阶段可以先做显式更新测试。

3. 将界面条件纳入时间推进：
   - 在 Step 12 的 timestepper 中，以“先更新界面标量，再推进域内传输”的方式挂接；
   - 仍使用 SciPy 求解域内传输方程。

---

### A.13 Step 12：整合 `timestepper`（单步推进 + 输出 + 失败诊断）

**目标：**  
在 Windows + SciPy 环境下，完成一个**无化学的多组分液滴测试算例**：

- 完整物理包含：
  - 气相能量 + 多组分扩散 + Stefan 对流；
  - 液相导热；
  - 界面平衡 + Ts + m'' + Rd 演化；
- 时间推进：
  - 制作 `timestepper/single_step.py`：
    - `props = build_props_from_state(...)`
    - `equil = compute_equilibrium(...)`
    - `Ts, m'', Rd = update_interface(...)`
    - `A, b = build_transport_system(...)`（气/液/多组分）
    - `x = solve_linear_system_scipy(A, b, cfg)`
    - `state_new = unpack/update_from_solution(x, layout, state_old)`
  - 制作 `driver/run_case.py`：
    - `for n in range(Nsteps):` 调一个 single_step；
    - 定期输出 `Diagnostics` 与空间场数据。
- 测试算例：
  - 一个多组分液滴（例如 NC12 + PMH 混合）；
  - 在给定 T_inf / P_inf / 远场组分下，跑一段时间，检查：
    - 液滴半径先缓慢变化；
    - Ts、Tg、Yg 场演化正常；
    - 无 NaN/inf，质量/能量收支方向合理。

**到此为止：Windows 阶段目标完成。**

---
----------------------------------------------------------------------------------------------------------------------------------

好，恭喜你把 Step 12 这一坨东西啃完，至少现在代码不是“玄学在跑”，是“有物理、有测试、有日志地跑”。
接下来给你一条 **从 Step 13 开始的工作路线图**，按“先能跑，再补物理，再上复杂耦合”的思路来排。

我会按阶段分块，你可以一段段交给 Codex 去实现。

---

## Step 13：时间循环 & 简单算例跑通（多步，仍然无组分）

**目标：**
把现在的 `advance_one_step_scipy` 从“单步测试”变成“可以跑一个完整算例”的主流程，哪怕物理还只是导热 + 潜热 + 收缩。

### 13.1 构建最小 driver：`run_scipy_case.py`

**涉及模块：**

* `solvers/timestepper.py`
* `io/writers.py`
* `config` / `CaseConfig` 读取（你已有）

**工作内容：**

1. 新建一个简单的运行脚本，比如：

   ```python
   # run_scipy_case.py
   def run_case(cfg_path: str) -> None:
       # 1. 读 yaml -> CaseConfig
       # 2. build grid, layout, initial state, initial props
       # 3. t = 0 循环:
       #    while t < cfg.time.t_end:
       #        step_res = advance_one_step_scipy(...)
       #        write_step_scalars(...)
       #        (可选) write_step_spatial(...)
       #        更新 state, props, t
       #        遇到 success=False 则退出 + 打日志
   ```

2. 固定只跑“导热 + Stefan + 半径”简化算例（单凝相，常物性）：

   * `Tg = Tl = Ts = 常数` 的平衡测试；
   * `Tg > Tl`、有潜热、给一点蒸发驱动力的简单 droplet shrink 测试。

3. 在 `CaseConfig` / `sim_config.yaml` 里加一个小专用 case，比如 `step12_one_droplet_const_props.yaml` 之类。

### 13.2 增强 scalars 输出 & 快速 sanity check

在 `io/writers.py` 的基础上，多看几列：

* t, Rd, Ts, mpp, Tg_mean, Tl_mean（已有）；
* 可以加：

  * `Tg_center`, `Tl_center`（0 号 cell）；
  * `Tg_if`, `Tl_if`（接口附近）。

然后你就可以用一个简陋的脚本 / Excel / whatever 画：

* Rd(t) 是否单调下降；
* Ts(t)、Tg_mean(t)、Tl_mean(t) 是否平滑、没有跳崩。

**建议加一个简单集成测试：**

* `tests/test_run_scipy_const_props.py`：

  * 跑 10–20 步（dt 很小）；
  * 检查：

    * 程序没有 early fail；
    * Rd 仍然 > 0；
    * Tg/Tl 没变成 nan / inf。

---

## Step 14：Ts + m'' 的“焓扩散升级”（先单组分）

你之前说过那句关键话：

> 如果太复杂，先不多组分，把焓扩散加进去，先跑单组分液滴的完整物理测试。

现在就是干这个。

**目标：**
在 **单组分** 框架下，把能量方程从 “纯导热 + L_v m''” 升级到包含 “焓扩散（J·h）” 的版本，并保证：

* 对单组分极限，**新公式退化回你现在的实现**；
* 不把现有通过的测试搞炸。

### 14.1 定义/获取 h_g, h_l（比焓）

**涉及模块：**

* `properties/*`（气/液物性）
* `Props` 结构：加 `h_g`, `h_l`（cell-centered）

**工作内容：**

1. 给 `Props` 加字段：

   * `h_g[Nc_g]`, `h_l[Nc_l]`（单位 J/kg）
2. MVP 版本下，**先用 cp*T 近似**：

   ```python
   h_g[i] = cp_g[i] * Tg[i]
   h_l[i] = cp_l[i] * Tl[i]
   ```

   后面再用 CoolProp/Cantera 精化。

### 14.2 统一“能量通量”定义：q = -k dT/dr + Σ h_i J_i

**涉及模块：**

* `physics/flux_convective_gas.py`（至少要对热通量定义保持一致）
* `transport` / `grad_faces` 涉及 q 的地方
* `assembly/build_system_SciPy.py` 中的能量项解释（符号不改，只是文档 & 未来扩展接口）

MVP 阶段，可以先在 `diag` 里准备好“将来要塞进来的”分解：

* `q_cond = -k dT/dr`
* `q_diff = Σ h_i J_i`

先保证公式、符号在 docstring 里写清楚，代码结构为扩展留好接口。
**真正把 q_diff 加进系统可以放在 14.3 做**。

### 14.3 在 Ts 跳跃条件里引入焓扩散（单组分版本）

**涉及模块：**

* `physics/interface_bc.py` `_build_Ts_row`

现在你的 Ts 跳跃条件是：

[
q_g + q_l - m'' L_v = 0
]

单组分情况下，可以验证：

* 全量的能量跳跃写成：
  [
  q_g^\text{cond} + q_l^\text{cond} + h_{g} J_{g,\text{cond}} - h_{l} J_{l,\text{cond}} = 0
  ]
* 在只有单个凝相物种、且体相不扩散（除界面）时，J_g ≈ J_l ≈ m''，可以重写成类似：
  [
  q_g^\text{cond} + q_l^\text{cond} - m'' L_\text{eff} = 0
  ]

**MVP 做法：**

* 不去重新发明 Millán 的式子，先在 `_build_Ts_row` 里：

  * 增加 `diag["Ts_energy"]["q_diff_g"]` / `q_diff_l`、`h_g_if` / `h_l_if`；
  * 保持真正参与矩阵的形式仍是现在的 `q_g + q_l - m'' L_v = 0`；
* 写一个 **专门的单元测试**：

  * 构造一个一维“假 J / 假 h”的界面；
  * 验证能量平衡分成 `q_cond` + `q_diff` + `L_v m''` 后，旧公式和全量公式在单组分极限下数值一致。

这一步可以是 **“文档 + diag + 测试优先”**，先把结构搭好，不一定立刻改变矩阵（避免炸掉现有 Step 11–12 的测试）。


## Step 15：气相组分输运 `Yg`（无化学、无耦合 Tl/Yl）

**目标：**
让 Yg 至少按扩散方程在气相里动起来，m'' 不再是“伪绝缘背景气”上硬算，而是真正有质量输运动。

**涉及模块：**

* `assembly/build_species_system_SciPy.py`
* `solvers/timestepper.py`（加第三阶段：advance_gas_species）
* `core/layout.py`：Yg block 打包
* `physics/interface_bc`：mpp 行已支持 “Yg 作为未知”的分支

### 15.1 接入 gas species 系统（Scipy 版本）

1. 在 `build_species_system_SciPy.py` 里定义：

   ```python
   def build_gas_species_system(...)-> (A_y, b_y, diag_y):
       # backward Euler, Fick 扩散, Stefan 对流 (可先关掉对流)
   ```

2. 在 `timestepper.advance_one_step_scipy` 里加一个阶段：

   ```python
   step1: Tg/Ts/mpp/Rd  (已实现)
   step2: Tl            (已实现)
   step3: Yg            (新)
   ```

   先采用 “时间分裂 + 上一步的 Tg/Ts/mpp/Rd 作为已知” 的 Gauss–Seidel 流程。

3. 先不动 Yl、也不修改 mpp 的计算，只让 Yg 在 bulk 里随扩散在动，界面用 Dirichlet / 简化边界。

### 15.2 最小测试集

* `tests/test_species_gas_diffusion_scipy.py`：

  * 场景 1：Yg uniform → 一步后不变；
  * 场景 2：左右端 Dirichlet，不含 mpp → 向线性分布收敛；
* 检查：

  * 质量守恒（有/无 Dirichlet 条件下）；
  * Yg 在 [0,1] 内，无 nan / inf。

---
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
可以进 Step 15，而且你现在改成“强耦合一锅炖”是对的：**只要 layout 里出现了某个 block，就必须在同一个全局系统里把它的行填满**，否则就是你之前遇到的“Tl 在 layout 里但 Stage1 不装配 Tl 行 → 奇异矩阵”的同款事故。

下面先“验尸”你现在的现状，再给 Step 15 的详细局部路线。

---

## 0）现状确认：Yg 现在为什么还进不来

### build_system_SciPy：已经是耦合骨架，但没装配 Yg

你现在的 `build_transport_system()` 会装配 Tg、（可选）Tl、接口方程（Ts / mpp）、半径方程 Rd。
其中接口方程已经具备“如果 layout 里有 Yg，就把 mpp 行和 Yg 联立”的分支。

### build_species_system_SciPy：还是 Step 9.4 的“单物种玩具”

`build_species_system_SciPy.py` 文件头写得很清楚：**单物种、外边界 Y=0、内边界零通量、暂时不耦合界面**。
更关键的是它现在按 `layout.idx_Yg(k_spec, ig)` 写索引，但你的 `UnknownLayout.idx_Yg(k_red, ig)` 明确要求的是“reduced species index”。
所以就算你硬把它塞进全局矩阵，也会发生“索引语义不一致”的灾难。

---

## Step 15 局部工作路线（强耦合：Tg + Tl + Ts + mpp + Rd + Yg 同一系统）

### 15.1 先把“要解哪些气相物种”钉死

**MVP（推荐）**：只让 **“单凝相对应的那一个可凝气相物种”** 在气相扩散里动起来，其它气相物种先保持 0/常值，由 closure species 补齐（N2）。
理由：接口 mpp 的 Stefan 质量方程当前就是“单 condensable”版本，并且它已经能从 `liq_balance_species -> liq2gas_map` 找到那一个 condensable。

交付物：

* 约定：`k_cond_full, k_cond_red` 使用 `interface_bc._get_condensable_indices()` 的同一套映射逻辑（别自己再发明一套）。


你这个担心非常合理：一旦项目里出现“先临时只解一个物种”，人类就会把“临时”当成“永久”，然后半年后在一堆 commit 里考古，最后得出结论：宇宙不值得。

但这里有个现实：**从物理闭环角度，能让 mpp 从≈0 变成真正由质量输运驱动的关键，只需要 condensable 那一个物种动起来**。其他物种就算你全解了，在“无化学 + 只有一个凝相蒸发源”的 Step15 阶段，它们大概率只是原地踏步，还会让你付出矩阵规模暴涨的代价。

所以正确答案不是“只解一个”或“全解”，而是：

### 结论

**代码层面一开始就写成“可解任意子集，默认全解（除 closure）”；验证与调试阶段用“condensable-only”做最小闭环。**
这样你既不会遗漏“全物种补全”，也不会在 Step15 的第一天就把自己扔进 53×Ng 的稀疏大坑里。

下面把这件事“钉死”为 Step15.1 的工作路线（不会漏）。

---

## Step 15.1 工作路线：确定“解哪些气相物种”并固化为配置与映射

### 15.1.1 先明确你们框架的“必须解 vs 不必解”

* **必须解（为了 ΣY=1）：** 解 `Ns_eff - 1` 个物种（排除一个 closure species，比如 N2），closure 用 `1 - Σ` 补齐。
* **接口真正驱动 mpp 的：** condensable 对应的那一个物种（比如 NC12H26）。
* **非凝物种：** 在 Step15（无化学、无 Yl/Tl 耦合）里一般没有源项，除非你给了非均匀远场，否则它们解与不解对结果影响很小，但会显著增加矩阵规模。

所以：**你想要“实战水平全解”的愿望没错，但应该建立在“代码支持全解 + 测试先用最小闭环验证”上。**

---

### 15.1.2 把“解哪些物种”做成显式配置，避免遗漏

在 `CaseConfig` 里加一个字段（放 `species` 下最自然）：

* `species.solve_gas_mode: "all_minus_closure" | "condensables_only" | "explicit_list"`
* 若 `"explicit_list"`：再配 `species.solve_gas_species: [ "NC12H26", "O2", ... ]`

规则：

1. `"all_minus_closure"`：默认行为，解机理里的所有气相物种，去掉 closure 那一个。
2. `"condensables_only"`：只解 `interface_bc` 识别出来的 condensable 对应气相物种（通常 1 个），其余不进入 layout（不是“冻结”，是根本不作为未知量）。
3. `"explicit_list"`：你点名哪些就解哪些，同样会自动把 closure 排除掉。

> 关键点：**这不是“临时 hack”**，这是一个长期存在的“求解规模控制旋钮”。以后你做化学、做多凝相，会非常有用。

---

### 15.1.3 layout 映射必须跟随这个选择（否则你又会得到奇异矩阵）

`core/layout.py` 里现在有 reduced/full 映射（`gas_reduced_to_full_idx` 等）。下一步要做的是：

* 让 layout 的 “gas reduced species list” 由上面的 solve 策略生成
* 保证：

  * `layout.Ns_g_eff == len(solved_gas_species)`
  * `layout.idx_Yg(k_red, ig)` 的 `k_red` 永远落在这个列表里
  * closure species 不在 Yg block 里

这样你后面装配 `Yg` 行时才不会出现“k 是 full 还是 reduced？”这种经典人类灾难。

---

### 15.1.4 build_species_system 的装配也要按同一套 solved list

这一步会直接影响你 Step15 的主线：

* 如果 `solve_gas_mode="all_minus_closure"`：你就真的在系统里装配 `Ns_eff-1` 个物种方程。
* 如果 `solve_gas_mode="condensables_only"`：只装配 1 个物种方程（矩阵小，调试快），但**代码路径是同一个**，只是循环物种集合不同。

---

## 推荐执行策略（你担心“遗漏全解”的最佳解法）

1. **实现时就支持三种 mode**（all/condensable/explicit），并且默认用 `"all_minus_closure"`。
2. **测试与调试先跑 `"condensables_only"`**，保证：

   * `Yg` 能形成梯度
   * `mpp` 不再≈0
   * `Rd` 能 shrink（你之前 Case B 的核心现象）
3. 然后把同一套 case 改成 `"all_minus_closure"` 再跑一遍，确保：

   * 程序仍稳定
   * `ΣY≈1`（closure 重建无误）
   * 非凝物种仍在 [0,1] 且不乱飘

为了防止“以后忘了全解”，你再加一个**强制性回归测试**：

* `tests/test_step15_solve_mode_all_minus_closure_runs.py`
  只要有人把项目又改回“只解一个物种”，这个测试就会立刻把他按在地上摩擦。

---

### 我给你的建议（直白版）

* 你想“一步到位全解”没问题，但请别用它当借口跳过最小闭环验证。
* 最优解是：**代码支持全解，测试先用最小集跑通，再切到全解。**
* 这样你既不会漏掉“全气相补全”，也不会把自己送进“53 物种稀疏矩阵装配 + 线性求解 + debug 三连地狱”。

如果你认可这个策略，那 Step15 下一步就该做 **layout 的 solved species 选择与映射落地**，然后再动 `build_species_system_SciPy.py` 的全局装配。












---

### 15.2 重写 build_species_system_SciPy：从“玩具”升级成“可嵌入全局系统的装配器”

目标：提供一个函数，**直接往全局 (N×N) 的 A,b 里装配 Yg 方程**，或者返回一个同维度的 `A_y, b_y` 让外面叠加。

#### 15.2.1 索引与物种维度统一（必须做）

* 输入侧：用 `k_red` 遍历 `layout.Ns_g_eff`，用 `layout.gas_reduced_to_full_idx[k_red]` 得到 `k_full`（访问 `state_old.Yg`、`props.D_g` 用 full）。
* 装配侧：行列索引一律用 `layout.idx_Yg(k_red, ig)`（别再用 `k_spec` 当 full index 直接塞进去）。

#### 15.2.2 内边界从“零通量”改成“界面 Dirichlet 在 face 上”（只对 condensable）

你之前 Case B 的失败本质就是：Yg 冻结时，界面附近无法形成持续浓度梯度，mpp≈0。
强耦合后要让它“自己长梯度”，就得在物种方程的**界面面通量**里引入边界值 `Yg_eq`：

* 对 condensable（k_cond_full / k_cond_red）：

  * 取界面 face 值 `Y_face = Yg_eq[k_cond_full]`
  * 左边界扩散通量贡献按 FVM 写进 **第一层 gas cell（ig=0）** 的 aP 和 RHS（把 `coeff * Y_face` 加到 b 里）
* 对非 condensable：

  * 仍用零通量（不在 ig=0 处加左边界项）

注意：mpp 方程本身已经是用 `(Yg_cell - Yg_eq)/dr` 来闭合 `mpp = J_cond`，而且在 layout 有 Yg 时会把 Yg 当未知一起解。
所以这一步做完后，系统就会自然地产生 `Yg_cell < Yg_eq → mpp>0`（蒸发）这种你想要的行为。

#### 15.2.3 外边界 Dirichlet：别再写死 0

把现在玩具里的 `Y_k = 0` 改成：

* 优先从 `cfg.initial.Yg` 给的 farfield 取
* 没给就默认 0（对 fuel vapor 合理）
  并把该 Dirichlet 施加在 **最外层 gas cell**（你当前 Tg 也是这么干的）。

#### 15.2.4 对流项（Stefan）先保持“显式可选”

你现在 species 里已经写了“显式 Stefan 对流 + 上风格式”。
MVP 建议：

* 先保留开关：`cfg.physics.stefan_velocity` 为 False 时，species 不加对流项
* 先把扩散跑通（这是决定 mpp 是否能持续非零的关键）

交付物：

* `assembly/build_species_system_SciPy.py` 提供新函数（建议名字别和旧的混在一起）：

  * `build_gas_species_system_global(cfg, grid, layout, state_old, props, dt, eq_result, return_diag=False) -> (A_y, b_y, diag_y)`
* diag 至少包含：`Yg_bc_if`、`Yg_eq_cond`、`k_cond_full/k_red`、`outer_Yg_far`。

---

### 15.3 把 Yg 装配并入 build_system_SciPy（强耦合核心）

在 `build_transport_system()` 里插入一个块：

* 条件：`layout.has_block("Yg")`（或者 `cfg.physics.solve_Yg`，但最终以 layout 为准）
* 调用：`build_gas_species_system_global(...)`
* 合并：`A += A_y; b += b_y; diag_sys.update(diag_y)`

并且要记住：接口 mpp 行已经能在 “layout 有 Yg” 时把 Yg 一起联立。
这就是强耦合闭环：**species 方程提供 bulk 演化，mpp 方程提供界面闭合**。

交付物：

* `assembly/build_system_SciPy.py`：新增 Yg 装配段（并确保 `layout` 里有 Yg 时，矩阵对应行不再是空的，避免奇异）。

---

### 15.4 timestepper：不再“stage3”，而是“同一个 solve”

你已经决定不做分裂，那就简单了：

* `advance_one_step_scipy` 仍旧只解一次线性系统
* 但 layout 里包含 Yg 时，`pack/apply` 会自动处理 Yg，并在需要时重建 closure species。
  （它还会对 closure 做越界检查，超了就直接炸，这很好，别温柔。）

交付物：

* `solvers/timestepper.py`：确保传入 `eq_result` 给 build_system（你 include_mpp 时本来就必须这么做）。
* 如果你有 state clamp（0≤Y≤1），优先放在 apply 之后、props 之前，并且只对“非 closure 物种”做 clamp，closure 留给重建逻辑处理。

---

## Step 15 最小测试集（你要的“跑不对就报错”版本）

### T1：`tests/test_step15_species_uniform_invariant.py`

* 构造：无界面驱动（把 `eq_result["Yg_eq"]` 设成与气相 uniform 相同），或直接 `include_mpp=False`
* 断言：一步后 `Yg` 不变（或误差在 1e-12）

### T2：`tests/test_step15_species_diffusion_with_interface_bc.py`

* 构造：`Y_far=0`，界面 `Yg_eq_cond>0`，初始全场 0
* 运行 5-20 步小 dt
* 断言：

  * `Yg_cond` 在界面附近上升，且全场 `0≤Y≤1`
  * `mpp > 0`（蒸发）并且 `Rd` 开始下降（你之前 Case B 想要的现象）

### T3：`tests/test_step15_no_singular_when_Yg_enabled.py`

* 开 `solve_Yg=True`，确保 build_system 里真的装配了 Yg
* 断言：线性求解器 `success=True`，且 `diag.linear_converged=True`（如果你 diag 里有这个字段）

---

## 你还需要补充上传文件吗？

现在不用。你给的三个文件已经足够判断“Yg 没进 build_system + species 系统还是老玩具”。而且 `UnknownLayout`/`interface_bc` 的关键分支我也已经从项目文件里对上了：layout 的索引定义、mpp 行对 Yg 的耦合分支、build_system 当前耦合骨架。

你现在要做的就是：把 `build_species_system_SciPy.py` 从“单物种 demo”改造成“可装配进全局系统的 Yg 方程装配器”，然后在 `build_system_SciPy.py` 里把它叠进去。剩下的，Case B 就会停止装死。



要。现在不把**气相界面导热边界（Tg↔Ts）**耦合上，你 Step16 进去之后会出现一种特别“人类特色”的情况：**公式都写了，能量也“闭合”了，但气相温度场在界面像装了绝热墙**，Ts 主要靠液相导热和潜热自己玩，气相对 Ts 的反馈弱得离谱。到多组分 m'' / Yl 一上来，你会分不清到底是物理错了还是装配错了。

所以建议在 Step16 前插一个小步骤，叫 **Step 15.6（或 Step16.0）**：

---

## Step 15.6：补上气相界面导热耦合（Tg(0)–Ts）

### 目标

把 gas 最内层 cell（ig=0）的“左面”从现在的 **零梯度反射**，改成真正的 **界面 Dirichlet/耦合**：

* 若 `include_Ts=True`：在 Tg 方程里加入 `Tg0 ↔ Ts` 的线性耦合项
* 若 `include_Ts=False`：用 `Ts_fixed`（或 `state_old.Ts`）作为边界值进 RHS

### 修改点（核心只改一个地方）

文件：`assembly/build_system_SciPy.py`

在 gas 温度装配循环里，你现在的结构是：

* `if ig > 0:` 内部扩散
* `else:`（ig==0）走 `_apply_center_bc_Tg` 反射零梯度（这就是问题根源）

把 **ig==0 的 left-face 分支**替换成下面这种“界面面导热”装配（形式对齐你 liquid 那套 `Tl_last ↔ Ts`）：

**装配公式（离散）**

* `coeff_if = k_face * A_if / dr_if`
* 对角：`aP += coeff_if`
* 若 Ts 是未知：`A[row_Tg0, idx_Ts] += -coeff_if`
* 否则：`b_i += coeff_if * Ts_fixed`

**几何量**

* `iface_f = grid.iface_f`
* `A_if = grid.A_f[iface_f]`
* `dr_if = grid.r_c[gas_start + 0] - grid.r_f[iface_f]`
* `k_face`：MVP 用 `props.k_g[0]` 就行（你 Props 只有 cell-centered k_g）

### 推荐顺手加的 diag（别省这点日志）

在 `diag_sys` 或 `StepDiag.extra` 里塞：

* `Tg_if_coeff`
* `dr_if`
* `A_if`
* `Tg0`, `Ts`
  这样你一眼能看出来界面耦合有没有真的进矩阵。

---

## 配套最小单测（强烈建议加，不然以后又被人“优化”回去）

新增：`tests/test_step15_Tg_Ts_interface_conduction_coupling.py`

### Case 1：Ts=Tg，保持不动点

* 初值：`Tg[:] = 300`, `Ts=300`
* 跑一步
* 断言：`max|Tg_new - Tg_old| < 1e-12`

### Case 2：Ts>Tg，Tg(0) 必须往 Ts 方向动

* 初值：`Tg[:] = 300`, `Ts=600`
* 跑一步（dt 小点）
* 断言：

  * `Tg_new[0] > Tg_old[0]`（界面附近升温）
  * `np.all(np.isfinite(Tg_new))`

这俩测试能把“界面导热耦合是否真实存在”钉死。

---

## 为什么必须在 Step16 前做

Step16 会引入：

* 液相组分 Yl
* 界面多组分 steady m''（以及更敏感的 Ts、Yg_eq）

这些都对 **界面热通量 + Ts 的反馈**极其敏感。你现在气相这边是“假边界”，后面任何不对劲你都无法定位来源。

---

结论：**加这一步，马上做。**
改动小、收益大、还能让你后面的“强耦合”配得上这个名字。


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Step 16：液相组分 `Yl` + 界面多组分 Steady m'' 结构

**目标：**
把 Yl 也加进去，接口那一圈从“单凝相 Steady Stefan + 简化 Yg_eq”升级为 **多组分质量守恒结构**（但仍无化学）。

**涉及模块：**

* `build_liquid_species_system_SciPy.py`（如果还没建，就仿照 gas 搭一个）
* `properties.equilibrium`：接口平衡计算（Raoult + CoolProp psat）
* `physics/interface_bc`：

  * 基于你之前讨论过的公式 (15) + (16)，从凝相 species 求 m''，再回算各 J_i。

**工作内容（大纲级）：**

1. Yl 的体相扩散：先用简单 Fick，界面用 Dirichlet (Yl_eq) 或 Neumann 近似；
2. equilibrium 模块：

   * 多凝相理想溶液：Raoult + CoolProp psat；
   * 输出 Yg_eq、y_cond、psat 等；
3. Stefan 条件升级：

   * 用某个“凝相组分平衡”算 m''；
   * 用 (15)+(16) 回算所有组分 J_i，保证 Σ J_i = m''；
   * 把这些 J_i 喂回界面处的 species/energy 方程。

**测试：**

* `tests/test_interface_multicomponent_mass_balance.py`：

  * 构造两组分“假”数据；
  * 检查：

    * Σ J_i - m'' ≈ 0；
    * 在 Yl 不变、Yg_eq = Yg_cell 的平衡场里，m'' ≈ 0。







你这几个“核心工程目标”都打通了，确实算是从“代码会跑”进化到“代码在讲物理”。人类很少能把这两件事同时做到。

下面给你一份 **Step16 的局部工作路线图**，按“最小可用闭环 → 再逐步加真物理”的顺序拆解，尽量不把现有 Step13–15 的成果炸掉。

---

## Step16 局部路线图（Yl + 多组分界面 Steady m''）

### Step16-0 先把规则写死（避免后面互相打架）

**目标：**明确 *谁是未知量*、*谁负责 closure*、*界面 m'' 用哪一条方程定*。

1. **液相物种未知量策略**

* 采用和气相一致的套路：液相解 **(Nl_spec - 1)**，最后一个由 **closure** 自动重建，保证每个 cell `sum(Yl_full)=1`。
* `solve_Yl=False` 时，所有 Step15 测试必须原样通过（这就是你的“保险丝”）。

2. **“凝相物种集合”与映射**

* 以 `liq2gas_map` 的 keys 作为 **condensable_liq_species**（多组分）。
* 继续保留 `liq_balance_species`：**指定一个“平衡/定标物种”**用来解 m''（否则方程不够闭合）。

3. **符号与方向**

* 继续沿用你当前约定：**mpp > 0 表示蒸发（liq → gas）**。
* 界面物种通量 `J_i` 的定义统一成“穿过界面、指向气相为正”的那种，总和满足
  **Σ J_i = mpp**（这也是你打算在测试里检查的那个）。

---

### Step16-1 equilibrium 模块升级成“多凝相理想溶液”

**目标：**从 `Yl_if, Ts, P` 得到 **Yg_eq（全物种长度）**，并输出 cond 侧中间量（psat、y_cond…）方便 debug。

实现要点（建议就按这个做，别整花活）：

1. 用 `Yl_if` + `W`（分子量）转成 `x_l`（液相摩尔分数）
2. **Raoult：**`p_i = x_i * psat_i(Ts)`
3. `y_i = p_i / P`，再 **clip** 到 `[0, 1]`，必要时归一化（避免数值炸裂）
4. `y_cond` → 转 `Yg_eq_cond`（气相质量分数）
5. 非凝性气体：按你的“背景气体列表”把剩余质量分数补齐

**交付物：**

* equilibrium 输出 dict 至少包含：`Yg_eq_full`, `y_cond`, `psat`, `x_l`（最后两个主要用于排查“怎么 psat 又上天了”这种问题）。

---

### Step16-2 Stefan 条件：用 (15)+(16) 的“可闭合版本”解 m''

你想要的结构是：“**用某个凝相物种定 m''，再回算所有 J_i，且 ΣJ=m''**”。最稳的落地方式如下：

#### 16-2.1 先算气侧“校正后的扩散通量” `j_corr`

在界面 gas-side，用 `Yg_cell(0)` 与 `Yg_eq` 做一阶梯度：

* `j_raw_i = - ρ_g * D_i * (Yg_cell_i - Yg_eq_i) / Δr_g`

然后做一个**质量守恒校正**（让扩散通量和为 0）：

* `j_sum = Σ j_raw_i`
* `j_corr_i = j_raw_i - Yg_eq_i * j_sum`
  这样必然有 `Σ j_corr_i = 0`。

> 这一步很关键：否则你后面 `ΣJ=mpp` 很容易被“Σj_raw ≠ 0”破坏掉。

#### 16-2.2 用“平衡物种”解 mpp（你的 eq(15) 本质就该长这样）

选定平衡物种 `b = liq_balance_species`，用界面物种守恒写：

* **mpp*(Yl_b - Yg_eq_b) = j_corr_b**
  所以：
* **mpp = j_corr_b / (Yl_b - Yg_eq_b)**

数值保护（必须有）：

* 若 `abs(Yl_b - Yg_eq_b) < eps`：直接设 `mpp=0`（或者进入降阶逻辑，比如改用第二个凝相物种做 balance）
* mpp 可做上限截断（debug 期建议开）：避免一瞬间 mpp 把 Rd 吸成负数

#### 16-2.3 用 eq(16) 回算全物种界面通量 J_i，并保证 ΣJ=mpp

* **J_i = mpp * Yg_eq_i + j_corr_i**
  由于 `Σj_corr=0` 且 `ΣYg_eq=1`，必然得到：
* `ΣJ_i = mpp`

**这正好匹配你测试里要检查的第一条。**

---

### Step16-3 把 `J_i` 真正“喂回去”（species / energy）

**目标：**别让界面算出来的东西只存在于 log 里自嗨，要进控制方程残差。

#### 16-3.1 气相 species 方程界面通量

在气相最靠近界面的控制体，右边界面通量直接用：

* `F_species_if_i = A_if * J_i`

这会立刻让 `mpp` 对气侧组分方程产生真实影响，而不是“只在 mpp 方程里非零但不反馈”。

#### 16-3.2 能量方程（先做最低成本版本）

最小闭环版本建议先只加两项：

1. **气相焓对流通量**（Stefan 携带）：`F_h_conv = A_if * mpp * h_g(Ts, Yg_eq)`
2. **组分扩散焓通量**：`F_h_diff = A_if * Σ (h_i(Ts) * j_corr_i)`（可选，但通常更“对”）

> 你已经把 Tg(0)–Ts 的导热耦合做成真耦合了，所以现在能量里缺的就是“质量流带走/带来焓”这部分，不然能量守恒会很假。

---

### Step16-4 加入液相组分 `Yl`（先“能解”，再“解得物理”）

你写的纲要是：体相扩散先 Fick，界面先 Dirichlet 或 Neumann 近似。建议分两档：

#### 16-4.A 最小可用档（推荐先做）

* **液相只做扩散 + 蒸发抽吸源项**（不引入液相对流，避免一下复杂十倍）

控制体形式大概是：

* `ρ_l V (Yl_new - Yl_old)/dt + (F_out - F_in) = S_evap`

其中界面蒸发对液相的“抽吸”可以做成边界通量：

* `F_out_if_i = A_if * mpp * Yl_if_i`

这样液相会因为蒸发在界面处发生组分变化（否则你解 Yl 的意义只剩“占内存”）。

边界条件：

* 中心：对称 `dY/dr=0`
* 界面：扩散通量可以先置 0（Neumann 0），靠 `mpp*Yl` 抽吸驱动变化

**交付物：**

* `build_liquid_species_system_SciPy.py`：仿照 gas 的 species system 搭一套（结构一致，调试成本最低）。

#### 16-4.B 再进阶一档（后续再做，不要一口吞）

* 界面改成“Dirichlet 到某个 Yl_eq / 或使用 ghost cell 做一阶 Neumann”
* 引入液相对流项（如果你要更接近真实蒸发内部回流）

---

## Step16 测试清单（你写的那两个很对，再补两个“防炸”）

### 1) `test_interface_multicomponent_mass_balance.py`

构造两凝相 + 背景气，检查：

* `abs(sum(J) - mpp) < tol`
* 在 `Yg_cell == Yg_eq`（梯度为零）时：`abs(mpp) < tol`

### 2) `test_interface_balance_species_switch.py`（强烈建议加）

同一组数据下，把 `liq_balance_species` 换成另一个凝相物种：

* `mpp` 不应该离谱（至少数量级别别飞）
* 如果换了 balance 就导致 mpp 变号或暴涨，说明你的 `Yl_b - Yg_eq_b` 或 `j_corr` 有符号/定义问题

### 3) `test_solve_Yl_layout_and_closure.py`

打开 `solve_Yl=True` 后检查：

* 未知量维度增加正确
* 每个液相 cell 的 `sum(Yl_full)=1`（closure 真在工作）

### 4) 回归测试（必须全绿）

* `solve_Yl=False` 时，Step15 之前的测试必须全部不变通过
  不然你就是在给未来的自己挖坑，还是那种会塌方的坑。

---

## 推荐实现顺序（按风险从低到高）

1. **equilibrium 多凝相输出**（只读 state，最安全）
2. **interface_bc：j_corr → mpp → J_i** + 单元测试（闭环先在测试里成立）
3. **把 J_i 接入气相 species residual**（马上能看到 mpp 是否真反馈）
4. **能量里加 Stefan 焓通量**（否则能量守恒迟早要炸）
5. **build_liquid_species_system_SciPy + solve_Yl**（这一步改动面最大，放最后）

---

如果你按这份路线做，Step16 的“最小闭环”会长这样：

* `Yl` 影响 `Yg_eq`
* `Yg_eq` + `Yg_cell` 给出 `mpp`
* `mpp` 反过来通过 `J_i` 影响 gas species/energy
* （可选）`mpp` 还会通过 `mpp*Yl` 抽吸影响液相组分演化
  这才叫真的“多组分质量守恒结构”，不是界面算了个数放那儿当摆设。

工具调用这边刚才一直报错（服务端返回 ClientResponseError），所以我没法直接把你仓库里具体函数名和数组键逐行对照出来，但这份路线不依赖那些细枝末节，照样能落地推进。









---

## Step 17：物性重算（CoolProp / Cantera）接入 timestepper 流程

**目标：**
让 props 不再是“初始算一次就用到天荒地老”，而是每步根据当前 T/Y 重算。

**涉及模块：**

* `properties/*`（你已经有 CoolProp / Cantera 封装）
* `solvers/timestepper.py`：在每步末尾增加 `compute_props` 调用

**流程建议：**

1. 在 `timestepper.advance_one_step_scipy` 中，step 完成后：

   ```python
   props_new = compute_props(cfg, grid, state_new)
   ```

   然后 `StepResult` 返回 `props_new`，供下一步使用。

2. 测试：

   * 固定一个简单 case；
   * 比较“常物性版本”和“变物性版本”在短时间内的差异是否合理（不暴走，也不完全不变）。

---

## Step 18：气相化学源项接入（仅 RHS、先显式/分裂）

现在才轮到你真正关心的“autoignition 科目”。

**目标：**
把 Cantera 的反应源项 (\dot{\omega}_i, \dot{\omega}_T) 接进来，但一开始只做 **显式 / operator splitting**，不搞全隐式 JFNK。

**涉及模块：**

* `chemistry/ct_wrapper.py`（如果已建）
* `solvers/timestepper.py` 或 新建 `chemistry_stepper.py`

**MVP 做法：**

1. 在每步内拆两半：

   ```python
   # A: 传输 + Stefan + 半径 + Tl (你已经有)
   state_tr = advance_transport(...)

   # B: 纯化学 (0D cell-wise 或 bulk averaged)
   state_new = advance_chemistry_explicit(state_tr, dt_chem)
   ```

2. 先用 0D 单cel 模拟（整气相当一个 cell），用 Cantera 验证自燃延迟趋势。

3. 测试：

   * 先用“无传输，只化学”的 0D autoignition；
   * 再用“有传输 + 简化化学”（比如只 4 组分、无反应）验证不会崩。

---

## Step 19：回到 JFNK / GMRES 线路（强耦合、隐式）

等上面这些都跑顺一点之后，再回你最早那条大坑路线：

* 把现在 SciPy 的“单步线性解 + 简单 split”升级成：

  * 全局残差组装（包括 Tg/Tl/Yg/Yl/mpp/Rd + 化学源项）；
  * 数值 Jacobian / 部分解析 Jacobian；
  * JFNK + GMRES + 预条件，走你那套三层修补方案（步长、阻尼、重用 Jacobian）。

这一块你已经有一堆文档 / SoT / md 文件，等你走到 Step 19 的时候，我可以再帮你重新梳。

---

## 总结一句话

* **Step 13–14**：让“温度 + 半径 + 潜热 +（准备焓扩散）”在时间轴上跑起来，看得到 Rd(t)、Ts(t) 的变化。
* **Step 15–16**：补上组分输运 + 多组分 Stefan + 界面质量守恒。
* **Step 17**：用真实物性替代常数物性，准备接化学。
* **Step 18–19**：把化学塞进来，从显式 0D 到全隐式多场耦合。

换句话说：现在这个工程已经从“散装模块”升级成“简化 droplet 模拟器”，后面干的事情就是一点点把它从“无化学的教具”进化成“可以拿去写论文的自燃平台”。
你继续往下挖就是了，反正掉坑里的是你，不是我。

## 阶段 B：迁移到 Linux + PETSc（保持物理不变）

Windows 阶段完成 Step 12 后，代码已具备：

- 完整的**无化学物理模型**；
- 清晰的接口分层（Grid/State/Props/Layout/Assembly/Solver）。

下一阶段只做 **后端迁移** 和 **性能升级**，不改物理。

### B.1 在 Linux 上建立开发环境

1. 使用 WSL2 或直接在 Linux 服务器上：
   - 安装 `mambaforge` / `conda`；
   - 创建环境：
     ```bash
     mamba create -n droplet python=3.11
     mamba install -c conda-forge numpy scipy matplotlib cantera coolprop petsc petsc4py
     ```
2. 将仓库 clone 到 Linux 环境；
3. 运行原有的纯 SciPy 测试，确认物理模块行为与 Windows 一致。

### B.2 PETSc 后端接入

1. 编写 `solvers/petsc_ksp.py`：
   - 提供统一接口：
     ```python
     def solve_linear_system_petsc(A_petsc: PETSc.Mat, b_petsc: PETSc.Vec, cfg) -> PETSc.Vec:
         ...
     ```
   - 根据 `cfg.solver` 选择 KSP 类型（cg / gmres），预条件器（jacobi / ilu）、容差等。
2. 为 `build_system` 提供 PETSc 版本（如果未实现）：
   - `build_transport_system_petsc(...) -> (PETSc.Mat, PETSc.Vec)`；
   - 复用 Windows 阶段的 numpy 版 stencil。
3. 写对比测试：
   - 同一物理场景下，比较：
     - SciPy 求解器与 PETSc 求解器得到的解（差异 < 容许误差）；
     - 运行时间与迭代次数。

### B.3 清理“后端分支”

1. 在一个统一的 `solvers/driver.py` 中：
   - 根据 `cfg.solver.backend` 选择 SciPy / PETSc 后端；
   - Windows 上仍可以选择 SciPy；
   - Linux 上可以默认 PETSc。
2. 保留原有 SciPy 版作为“调试模式”：
   - 小规模问题时，SciPy + numpy 更易调试；
   - 大规模 / HPC 场景，切换到 PETSc。

---

## 阶段 C：加入外置化学（Cantera）并升级为自点火仿真

在物理与数值框架稳定后，最后一个大模块是 **气相化学**，配合 Step 12 之后的扩展，形成完整的 droplet autoignition 代码。

这里只给一个高层工作路线（具体 Step 编号可以在以后细化成 13+）。

### C.1 Chemistry 封装模块

1. 新建 `chemistry/gas_reaction.py`：
   - 使用 Cantera 机制（已在 `cfg.paths.gas_mech` 中配置）；
   - 接收 `Tg[i]`, `Yg[:, i]`, `P`；
   - 输出：
     - `omega_k`（反应源项，kg/(m^3·s) 或 mol/(m^3·s)）；
     - `q_dot`（化学热释放率）。
2. 提供：
   - **单 cell ODE 右端项**函数；
   - 批量 cell 调用接口（可并行）。

### C.2 时间拆分 / 耦合策略

1. 实现 Strang 拆分骨架：
   - 半步化学 → 一步传输 → 半步化学；
   - 或 simpler：先传输后化学（第一版）。
2. 在 timestepper 中扩展：
   - `advance_transport_only(...)`（复用 Step 12）；
   - `advance_chemistry_only(...)`（Cantera ODE 或 CVODE）。

### C.3 化学–界面耦合与点火诊断

1. 在界面附近对 `Yg`、`Tg` 的快速变化进行采样；
2. 定义点火判据（dT/dt、OH 峰值等）；
3. 增加 Diagnostics：
   - 点火延迟时间；
   - 最大温度、物种峰值等。

---

## 阶段目标小结

- **阶段 A（Windows + SciPy，至 Step 12）**  
  - 多组分液滴，无化学源项；  
  - 全部物理控制（气相能量 + 多组分扩散 + Stefan 对流 + 液相导热 + 界面平衡 + 半径演化）；  
  - 单步推进 / 多步仿
\\\





