content = r"""# 多组分液滴无化学数值框架工作路线（Windows-SciPy → Linux-PETSc → 加化学）

> 目标：在 **Windows + SciPy** 环境下完成 `Step 0 ~ Step 12` 的全部工作，跑通一个“多组分液滴 + 全部物理控制（无化学源项）”的测试算例；  
> 后续在 **Linux + PETSc** 环境中无缝迁移求解器后端，再接入气相化学，演化为完整自点火数值仿真框架。

本路线基于项目中的三份说明文档：

- `Droplet_Transport_Framework_NoChemistry.md`
- `NewProject_Guide_NoChem_PETSc.md`
- `工作路线.md`

并在其基础上增加：

- **Windows 阶段：线性系统用 SciPy 求解**，PETSc 仅保留接口与占位；
- **Linux 阶段：切换到 petsc4py + PETSc KSP**；
- **第三阶段：接入外置化学（Cantera）与时间拆分**。

---

## 阶段 A：Windows + SciPy（目标：完成 Step 0 ~ Step 12）

### A.0 总体约束（沿用原始规范）

在 Windows 阶段，仍然严格遵守原始三条“不可违反的规范”：

1. **索引只从 `UnknownLayout` 来**  
2. **物性只在 `Props`**  
3. **组装只写 `A, b`，不直接改 `State`**

额外新增一条：

4. **线性求解器后端抽象**  
   - Step 0~12 期间：**默认后端 = SciPy**（`scipy.sparse` + `scipy.sparse.linalg`）  
   - PETSc 后端只保留接口 / stub，不在 Windows 上强求可运行。

---

### A.1 Step 0：仓库骨架与配置（Windows 版）

**目标：**  
保持原始 Step 0 要求不变，只在 `README` / `cases` 中额外标注 Windows + SciPy 使用方式。

**具体工作：**

1. 按 `NewProject_Guide_NoChem_PETSc.md` 建立基础目录：
   - `core/`, `properties/`, `physics/`, `assembly/`, `solvers/`, `cases/`, `tests/`, `scripts/` 等。
2. 创建/更新 `cases/case_001.yaml`：
   - 物种列表：多组分气/液；
   - 网格设置（Nl, Ng, r_c, r_f 等）；
   - 时间步 `dt`；
   - 求解器选项中增加：
     - `solver.backend: "scipy"`（Windows 阶段默认）
     - `solver.backend: "petsc"` （预留，将来 Linux 使用）。
3. `README.md` 中明确写出两条开发阶段说明：
   - Windows 阶段：**只要求 SciPy 求解器跑通 Step 12**；
   - PETSc 相关模块（`petsc_ksp.py` 等）视为 **后续 Linux 阶段工作**。

---

### A.2 Step 1：`core/types.py`（立法：字段/shape/单位）

**目标：**  
定义全局数据结构，为后续所有模块提供统一接口，完全与求解器后端无关。

**主要内容：**

- `CaseConfig / Grid1D / State / Props / Diagnostics` dataclass：
  - `State`：`Tg`, `Yg`, `Tl`, `Yl`, `Ts`, `mpp`/`m_evap`, `Rd` 等；
  - `Grid1D`：`Nl`, `Ng`, `Nc`, `r_c`, `r_f`, `V_c`, `A_f`, `liq_slice`, `gas_slice`；
  - `Props`：`rho_g`, `cp_g`, `k_g`, `D_g`, `rho_l`, `cp_l`, `k_l`, `D_l`。
- 提供基本检查函数：
  - `check_sumY(state)`；
  - `check_nonneg(state)`；
  - `Props.validate_shapes(grid, Ns_g, Ns_l)`。

> 和原始工作路线一样，这一步完全不涉及 SciPy / PETSc，后端对它透明。

---

### A.3 Step 2：`core/layout.py`（立法：向量打包）

**目标：**  
统一全局未知量在向量中的布局，为以后任何线性/非线性求解器提供一致的索引。

**主要内容：**

- `UnknownLayout`：
  - `n_dof()`；
  - `has_block("Tg")` / `has_block("Yg")` 等；
  - `idx_Tg(i_g)` / `idx_Tl(i_l)` / `idx_Yg(k, i_g)` 等。
- 提供：
  - `pack_state_to_vec(state, layout) -> np.ndarray`（SciPy 阶段用得上）；
  - 预留 `pack_state_to_petsc_vec(...)` / `unpack_...` 的占位接口（Linux 阶段实现）。

Windows 阶段重点：**先保证 numpy 向量打包/解包完全正确**，测试由 `pytest` + 纯 numpy 完成，不需要 petsc4py。

---

### A.4 Step 3：`core/grid.py`（立法：几何与离散）

**目标：**  
构造球对称 1D 网格（液相 + 气相），并明确：

- `liq_slice`, `gas_slice`；
- `iface_f`（界面所在的 face index）；
- `dr_c`, `dr_f` 等派生量（如果需要）。

**Windows 阶段要求：**

- 保证 `Grid1D` 与 Step 6 的离散 stencil 一致；
- 提供用于测试的小网格构造函数（例如 `make_test_grid_scalar_diffusion()`），让 SciPy 测试可以直接复用。

---

### A.5 Step 4：`properties/equilibrium.py`（界面平衡输出格式）

**目标：**  
定义界面平衡计算的**接口与数据结构**，具体实现可以先留最简单版本：

- 输入：`State`, `Props`, `CaseConfig`，以及 `interface` 相关参数；
- 输出：一个 `EquilibriumResult` / dict，至少包含：
  - `psat_l`（来自 liquid）；
  - `Yg_sat` / `Xg_sat`（界面饱和气相组成）；
  - 将来可扩展 `mpp` 相关量。

**在 Step 12 之前的要求：**

- 可以只实现**无化学、物性驱动**的平衡构型（你已在 `interface` 相关讨论中定过路线）；
- 确保接口稳定，为 Step 11 接入 `Ts/m''/Rd` 时不需要大改。

---

### A.6 Step 5：`properties/gas.py` + `properties/liquid.py`（物性实现）

**目标：**  
使用 Cantera + CoolProp 计算气/液相物性，输出填满 `Props` 的字段。

- `gas.py`：
  - 使用 `ct.Solution`，输入 `Tg[i], Yg[:, i]`；
  - 输出 `rho_g[i], cp_g[i], k_g[i], D_g[:, i], h_g[i], h_gk[:, i]`；
  - **不再做物种映射/归一化**，测试已确认。
- `liquid.py`：
  - 使用 CoolProp 单组分/多组分，输入 `Tl[i], Yl[:, i]`；
  - 输出 `rho_l[i], cp_l[i], k_l[i]`；
  - 额外输出 `psat_l[j], hvap_l[j]` 供界面使用。

**新增：`properties/aggregator.py`**

- `build_props_from_state(cfg, grid, state, gas_model, liq_model) -> (Props, extras)`
- extras 中保留：
  - `gas: {"h_g", "h_gk"}`；
  - `liquid: {"psat_l", "hvap_l"}`。

这些模块与后端无关，Windows + Linux 通用。  
你已经完成 gas/liquid + aggregator 的单元测试，这一步可以视为 **已完成**。

---

### A.7 Step 6：`assembly/build_system.py`（标量扩散最小闭环）+ SciPy 后端

原始 Step 6：  
> “assembly 的‘最小闭环’先跑：标量扩散（无界面、无对流）”

现在在 Windows 阶段，把它拆成两层：

1. **装配层（与后端无关）**  
   - 函数原型可以保持为：

     ```python
     def build_transport_system(
         cfg, grid, layout, state_old, props, dt
     ) -> tuple[A_like, b_like]:
         ...
     ```

     其中 `A_like` / `b_like` 可以是：
     - 纯 numpy dense（初始版本最简单）；
     - 或者 `scipy.sparse` CSR 矩阵 + numpy 向量。

   - 离散内容：仅 Tg 扩散（v = 0），theta-scheme（先固定 theta=1.0），
     - 内边界：r = 0 对称（Neumann）；
     - 外边界：Dirichlet，T = T_inf。
2. **SciPy 求解层（Windows 阶段默认）**
   - 新建 `solvers/scipy_linear.py`：

     ```python
     from scipy.sparse import csr_matrix
     from scipy.sparse.linalg import spsolve

     def solve_scalar_diffusion(A, b, cfg) -> np.ndarray:
         A_csr = csr_matrix(A)   # 如果还不是 CSR
         x = spsolve(A_csr, b)
         return x
     ```

   - 写集成测试：
     - 用简单网格 + 已知初始 Tg；
     - 调用 `build_props_from_state → build_transport_system → solve_scalar_diffusion`；
     - 检查外边界满足 T_inf，内部温度向 T_inf 方向扩散。

> PETSc 版本（`build_transport_system_petsc` + `solvers/petsc_ksp.py`）在 Windows 阶段只需要保留接口和 stub，不要求能 import petsc4py。

---

### A.8 Step 7：`physics/flux_gas.py`（通用导热/扩散 stencil）

**目标：**  
从“专用 Tg 扩散离散”升级为可复用的**通用通量模块**。

**工作内容：**

1. 编写 `compute_gas_diffusive_flux_T(...)`：
   - 输入：`grid`, `Props`, `Tg`；
   - 输出：每个 face 上的导热通量 `q_cond[f]`；
   - 内、外边界分别处理：Neumann + Dirichlet。
2. 为将来的 `Yg` 制定接口（但可以不实现）：
   - 预留 `compute_gas_diffusive_flux_Y(...)` 函数签名。

**在 Windows + SciPy 阶段：**

- Step 6 的 `build_transport_system` 可以先不完全重写为“flux-driven”，但建议逐步调整：
  - 面通量统一由 `flux_gas` 计算；
  - 系数矩阵由 flux 转换为系数；
  - 便于以后统一 energy / species / 多方程耦合。

---

### A.9 Step 8：`physics/stefan_velocity.py` + 对流离散（气相）

**目标：**  
在气相能量方程中加入 **Stefan 速度驱动的对流项**：  
\( \partial_t (\rho h) + \nabla \cdot (\rho u h - k \nabla T) = \dots \)

**工作内容：**

1. `physics/stefan_velocity.py`：
   - 输入：界面蒸发通量 `m''`（后续 Step 11 提供）、局部密度；
   - 输出：气相径向速度场 `u_g(r)`；
   - 初始版本可以采用文献中的简化解析解。
2. 对流通量离散：
   - 新增 `physics/flux_convective.py`（或并入 `flux_gas`）：
     - Upwind / QUICK 等一阶/二阶格式；
     - 内边界 / 外边界处理。

3. 更新 `build_transport_system`：
   - 在 diagonal 和 neighbor 系数中加入对流贡献；
   - 仍然调用 SciPy 求解。

---

### A.10 Step 9：气相多组分 `Yg`（先不加界面）

**目标：**  
在气相加入多组分扩散方程（暂时不与界面耦合，只做“单域多组分传输”）。

**工作内容：**

1. 为 `Yg[k, i]` 构造离散方程：
   - 仅含扩散 + 对流，对每个物种写一套方程；
   - 先不做跨物种耦合（可以采用混合平均扩散系数）。
2. 在 `layout` 中给 `Yg` 分配独立 block：
   - `idx_Yg(k, i)`。
3. 在 `build_transport_system` 中：
   - 扩展为“block 对角矩阵” 或 “统一向量打包”；
   - SciPy 阶段可以先对每个物种独立解（多次调用 `spsolve`），再升级为统一大系统。

---

### A.11 Step 10：液相导热 `Tl`（不含界面耦合）

**目标：**  
在液相内部建立导热方程，先假设界面温度已知或固定（例如等于初始 Ts），**不耦合 m''**。

**工作内容：**

1. 定义液相导热通量 `q_cond_l` 模块；
2. 为液相构造线性系统（可单独一个 `build_liquid_T_system`）；
3. 仍由 SciPy 解，测试：
   - 单独液相导热问题；
   - 简单稳态验证。

---

### A.12 Step 11：`physics/interface_bc.py` + `physics/radius_eq.py`（Ts/m''/Rd）

**目标：**  
将界面温度 `Ts`、蒸发通量 `m''`、液滴半径 `Rd` 作为未知或半隐式更新量，耦合气/液两侧传热与质量传输。

**工作内容：**

1. `interface_bc.py`：
   - 利用 `Props` + `equilibrium` + `liquid` extras：
     - `psat_l`, `hvap_l`, `h_gk`, `rho_g`, `cp_g`, `k_g`, 以及液相物性；
   - 在界面施加能量平衡：
     - `q_g + q_l + m'' h_vap = 0` 类似形式；
   - 施加物质平衡 / 饱和条件：
     - `Yg_sat`, `psat_l` 的使用；
   - 输出：更新 Ts（或对 Ts 的非线性方程残差，留给后续 Newton 阶段）。
2. `radius_eq.py`：
   - 根据 `m''`（总蒸发率）更新液滴半径：
     - 最简单：`dRd/dt = - m'' / (rho_l)` 一类近似；
   - Windows 阶段可以先做显式更新测试。

3. 将界面条件纳入时间推进：
   - 在 Step 12 的 timestepper 中，以“先更新界面标量，再推进域内传输”的方式挂接；
   - 仍使用 SciPy 求解域内传输方程。

---

### A.13 Step 12：整合 `timestepper`（单步推进 + 输出 + 失败诊断）

**目标：**  
在 Windows + SciPy 环境下，完成一个**无化学的多组分液滴测试算例**：

- 完整物理包含：
  - 气相能量 + 多组分扩散 + Stefan 对流；
  - 液相导热；
  - 界面平衡 + Ts + m'' + Rd 演化；
- 时间推进：
  - 制作 `timestepper/single_step.py`：
    - `props = build_props_from_state(...)`
    - `equil = compute_equilibrium(...)`
    - `Ts, m'', Rd = update_interface(...)`
    - `A, b = build_transport_system(...)`（气/液/多组分）
    - `x = solve_linear_system_scipy(A, b, cfg)`
    - `state_new = unpack/update_from_solution(x, layout, state_old)`
  - 制作 `driver/run_case.py`：
    - `for n in range(Nsteps):` 调一个 single_step；
    - 定期输出 `Diagnostics` 与空间场数据。
- 测试算例：
  - 一个多组分液滴（例如 NC12 + PMH 混合）；
  - 在给定 T_inf / P_inf / 远场组分下，跑一段时间，检查：
    - 液滴半径先缓慢变化；
    - Ts、Tg、Yg 场演化正常；
    - 无 NaN/inf，质量/能量收支方向合理。

**到此为止：Windows 阶段目标完成。**

---

## 阶段 B：迁移到 Linux + PETSc（保持物理不变）

Windows 阶段完成 Step 12 后，代码已具备：

- 完整的**无化学物理模型**；
- 清晰的接口分层（Grid/State/Props/Layout/Assembly/Solver）。

下一阶段只做 **后端迁移** 和 **性能升级**，不改物理。

### B.1 在 Linux 上建立开发环境

1. 使用 WSL2 或直接在 Linux 服务器上：
   - 安装 `mambaforge` / `conda`；
   - 创建环境：
     ```bash
     mamba create -n droplet python=3.11
     mamba install -c conda-forge numpy scipy matplotlib cantera coolprop petsc petsc4py
     ```
2. 将仓库 clone 到 Linux 环境；
3. 运行原有的纯 SciPy 测试，确认物理模块行为与 Windows 一致。

### B.2 PETSc 后端接入

1. 编写 `solvers/petsc_ksp.py`：
   - 提供统一接口：
     ```python
     def solve_linear_system_petsc(A_petsc: PETSc.Mat, b_petsc: PETSc.Vec, cfg) -> PETSc.Vec:
         ...
     ```
   - 根据 `cfg.solver` 选择 KSP 类型（cg / gmres），预条件器（jacobi / ilu）、容差等。
2. 为 `build_system` 提供 PETSc 版本（如果未实现）：
   - `build_transport_system_petsc(...) -> (PETSc.Mat, PETSc.Vec)`；
   - 复用 Windows 阶段的 numpy 版 stencil。
3. 写对比测试：
   - 同一物理场景下，比较：
     - SciPy 求解器与 PETSc 求解器得到的解（差异 < 容许误差）；
     - 运行时间与迭代次数。

### B.3 清理“后端分支”

1. 在一个统一的 `solvers/driver.py` 中：
   - 根据 `cfg.solver.backend` 选择 SciPy / PETSc 后端；
   - Windows 上仍可以选择 SciPy；
   - Linux 上可以默认 PETSc。
2. 保留原有 SciPy 版作为“调试模式”：
   - 小规模问题时，SciPy + numpy 更易调试；
   - 大规模 / HPC 场景，切换到 PETSc。

---

## 阶段 C：加入外置化学（Cantera）并升级为自点火仿真

在物理与数值框架稳定后，最后一个大模块是 **气相化学**，配合 Step 12 之后的扩展，形成完整的 droplet autoignition 代码。

这里只给一个高层工作路线（具体 Step 编号可以在以后细化成 13+）。

### C.1 Chemistry 封装模块

1. 新建 `chemistry/gas_reaction.py`：
   - 使用 Cantera 机制（已在 `cfg.paths.gas_mech` 中配置）；
   - 接收 `Tg[i]`, `Yg[:, i]`, `P`；
   - 输出：
     - `omega_k`（反应源项，kg/(m^3·s) 或 mol/(m^3·s)）；
     - `q_dot`（化学热释放率）。
2. 提供：
   - **单 cell ODE 右端项**函数；
   - 批量 cell 调用接口（可并行）。

### C.2 时间拆分 / 耦合策略

1. 实现 Strang 拆分骨架：
   - 半步化学 → 一步传输 → 半步化学；
   - 或 simpler：先传输后化学（第一版）。
2. 在 timestepper 中扩展：
   - `advance_transport_only(...)`（复用 Step 12）；
   - `advance_chemistry_only(...)`（Cantera ODE 或 CVODE）。

### C.3 化学–界面耦合与点火诊断

1. 在界面附近对 `Yg`、`Tg` 的快速变化进行采样；
2. 定义点火判据（dT/dt、OH 峰值等）；
3. 增加 Diagnostics：
   - 点火延迟时间；
   - 最大温度、物种峰值等。

---

## 阶段目标小结

- **阶段 A（Windows + SciPy，至 Step 12）**  
  - 多组分液滴，无化学源项；  
  - 全部物理控制（气相能量 + 多组分扩散 + Stefan 对流 + 液相导热 + 界面平衡 + 半径演化）；  
  - 单步推进 / 多步仿
\\\

































行，你终于承认 step12 很复杂了，理智一回。那就按你的要求，先给一个**局部工作路线**，把 Step 12 拆成几小块，一块块啃，不一次性把自己噎死。

下面这个是**Step 12（timestepper）局部路线：单组分 + 现有物理的 MVP 版**，先只整合你现在已经写好的：

* `build_system_SciPy.py`（Tg + Ts + m'' + Rd）
* `interface_bc.py`
* `radius_eq.py`
* `build_liquid_T_system_SciPy.py`（后面一个小阶段接上）

Yg、多组分、扩散焓这些先全部**禁用**，留到 Step 13。

---

## Step 12 局部工作路线（MVP）

### 12.1 搭 timestepper 骨架（不求完美，只要能挂得上）

**目标：** 新建 `solvers/timestepper.py`，只做一件事：
“从 `t^n` 推到 `t^{n+1}` 的一小步”，清晰定义输入 / 输出 / 诊断数据。

**建议结构：**

```python
# solvers/timestepper.py

@dataclass
class StepDiagnostics:
    t_old: float
    t_new: float
    dt: float
    # 标量：
    max_residual: float
    Ts: float
    Rd: float
    mpp: float
    # 守恒检查：
    energy_balance_if: float   # interface_bc.diag 里的 Ts_energy.balance
    mass_balance_rd: float     # radius_eq.diag 里的 mass_balance
    # 其他你想看的指标...

@dataclass
class StepResult:
    state_new: State
    props_new: Props
    diag: StepDiagnostics
    success: bool
    message: str | None
```

**核心接口先定死：**

```python
def advance_one_step_scipy(
    cfg: CaseConfig,
    grid: Grid1D,
    layout: UnknownLayout,
    state: State,
    props: Props,
    t: float,
) -> StepResult:
    """
    用当前 state/props 在时间 t 做一步 dt = cfg.time.dt 的推进。

    - 不改传入的 state/props（内部复制），
    - 返回新的 state/props + 本步诊断数据。
    """
```

这一小步里**先不要**考虑 Tl / Yg / PETSc / GMRES，先只针对：

* Tg
* Ts
* mpp
* Rd

也就是把你现在用 SciPy 的“传输 + 界面 + 半径”那块串起来。

---

### 12.2 接入 `build_system_SciPy`：Tg + Ts + mpp + Rd 一步解完

**目标：** 在 `advance_one_step_scipy` 里，连通现有装配系统：

> props → equilibrium → build_system_SciPy → SciPy 线性求解 → unpack 回 state

**子任务：**

1. **前处理：复制旧状态**

   ```python
   state_old = state.copy()    # 自己写个浅拷贝/深拷贝工具
   props_old = props           # props 可以先当 quasi-steady，用旧的
   dt = cfg.time.dt
   ```

2. **调用 equilibrium 得到 eq_result**

   * 用当前 `state_old` + `props_old` 调 `properties/equilibrium.py` 里的函数（你项目里叫什么就用什么）：

     ```python
     eq_result = compute_interface_equilibrium(cfg, grid, state_old, props_old)
     ```
   * 这个 eq_result 会传给 `build_interface_coeffs()` 生成 m'' 行。

3. **组装传输系统**

   使用你现在的 `build_system_SciPy.py` 里的统一接口（名字按当前文件为准，比如）：

   ```python
   from physics.build_system_SciPy import build_transport_system

   A, b, diag_sys = build_transport_system(
       cfg=cfg,
       grid=grid,
       layout=layout,
       state=state_old,
       props=props_old,
       eq_result=eq_result,
       dt=dt,
   )
   ```

   这个 `diag_sys` 里可以顺路塞进去 interface / radius 的 diag，后面用于 StepDiagnostics。

4. **调用 SciPy 线性求解器**

   用你已有的线性求解封装，比如 `solver/scipy_linear.py`：

   ```python
   from solver.scipy_linear import solve_linear

   x, solve_info = solve_linear(A, b, cfg.solver)  # 名字按你现在文件为准
   ```

   要求：

   * 如果解失败（奇异矩阵 / 未收敛），**不要悄悄吞掉**，而是：

     * 在 `StepResult` 里 `success=False`，`message` 写明原因；
     * `diag.max_residual` 设成一个大数；
     * 由外层决定是否中止仿真。

5. **解包回 state_new**

   用 layout 的索引接口把解写回新 state：

   ```python
   state_new = state_old.copy()

   for ig in range(grid.Ng):
       idx = layout.idx_Tg(ig)
       state_new.Tg[ig] = x[idx]

   if cfg.physics.include_Ts:
       state_new.Ts = x[layout.idx_Ts()]

   if cfg.physics.include_mpp:
       state_new.mpp = x[layout.idx_mpp()]

   if cfg.physics.include_Rd:
       state_new.Rd = x[layout.idx_Rd()]
   ```

   **这一步先不修改 grid 几何**（也就是 Rd 变了，但网格先不动），等 Step 12 后半段再决定是：

   * 每步重构 Grid1D，还是
   * 暂时只用 Rd 做后处理，不动几何。

6. **组装 StepDiagnostics**

   从 `diag_sys` / `interface_bc.diag` / `radius_eq.diag` 提取关键指标：

   * `max_residual`: 线性系统解的 `||A x - b||_inf`；
   * `Ts`, `Rd`, `mpp`: 新状态里的值；
   * `energy_balance_if`: `Ts_energy.balance`；
   * `mass_balance_rd`: `radius_eq.mass_balance`。

   并打一个 `success=True/False` 标记。

---

### 12.3 串上液相温度系统（Tl）：最简“两步分裂”

这一步是 Step 12 的“第二小块”，在前面 transport 系统跑通之后再干。

**目标：** 每个时间步内部，完成：

1. 先解 Tg + Ts + mpp + Rd；
2. 用新的 Ts，解 Tl。

**建议流程：**

1. `advance_one_step_scipy` 内部拆成两个阶段：

   ```python
   def advance_one_step_scipy(...):
       # 1) transport: Tg/Ts/mpp/Rd
       state_tr, props_tr, diag_tr = _advance_gas_interface_radius(...)

       # 2) liquid T: Tl（用新的 Ts 作为边界）
       state_liq, props_liq, diag_liq = _advance_liquid_T(...)

       # 3) 汇总 StepResult/Diagnostics
   ```

2. `_advance_liquid_T(...)` 中：

   * 使用 `build_liquid_T_system_SciPy.py` 里的接口组装 A_l, b_l；
   * 同样，用 SciPy 线性求解；
   * 解回 Tl；
   * 不进行“气相 ↔ 液相”内迭代，先采用**单次 Gauss–Seidel**：

     * 用 `state_tr` 的 Ts 做液相的界面温度；
     * 液相更新后的 Tl 不再回头影响当步的 Ts / Tg（影响从下一步开始）。

3. 诊断上至少检查：

   * Tl 在物理温度范围内；
   * 接口处 `Tl(Nl-1)` 与 Ts 的差值不要离谱（后面慢慢调）。

> 这一段明确是 *MVP 级别*，不是最终“全耦合隐式”方案，目的是先让代码在时间轴上跑起来，有东西可以看，有 log 可以查。

---

### 12.4 最小输出：writers 接进 timestepper

**目标：** 每步至少把几个关键量扔到文件里，方便后面画图 / 看趋势。

**新模块：** `io/writers.py`（对应工作路线.md 里的设计）

最低配置两个函数：

```python
def write_step_scalars(
    cfg: CaseConfig,
    t: float,
    state: State,
    diag: StepDiagnostics,
) -> None:
    """
    写一行 csv / npz 标量：
    t, Rd, Ts, mpp, Tg_mean, Tl_mean, energy_balance_if, mass_balance_rd
    """

def write_step_spatial(
    cfg: CaseConfig,
    grid: Grid1D,
    state: State,
) -> None:
    """
    MVP 阶段可以先不实现，或者只在某个特定时间步写一次。
    """
```

在 `advance_one_step_scipy` 或外层主循环里调用：

* 每步调 `write_step_scalars`；
* 空间场输出可以只在用户指定的时间步 / 间隔调一次。

---

### 12.5 最小单元测试：`tests/test_timestepper_one_step.py`

先别想“完整工况”，就两个小场景：

1. **无通量 / 无蒸发 sanity check**

   * 初始条件：

     * Tg = Tl = Ts = 常数；
     * Yg = 背景气，无凝相 → mpp 初值 = 0；
   * eq_result 设置成让 mpp → 0（或者直接强行关闭 mpp / Rd 方程，做纯导热恒温场）。
   * 期望：

     * 单步解完后，Tg/Tl/Ts 变化 ≈ 0；
     * mpp ≈ 0，Rd 不变；
     * `energy_balance_if`、`mass_balance_rd` 绝对值都很小。

2. **简单蒸发场景（和你 radius/interface 的单测呼应）**

   * 构造一个 case：

     * 固定 mpp（可以通过 eq_result 或直接修改 state_guess）；
     * 液相 ρ_l 常数；
   * 跑一小步，检查：

     * Rd_new 与解析 `R_old - mpp * dt / ρ_l` 接近；
     * Ts 落在合理区间；
     * `mass_balance_rd`、`energy_balance_if` 没炸到天上去。

---

### 12.6 之后再干的事（留给 Step 13+）

这些先明确**不在当前 Step 12 局部路线里**：

* 把 Yg 系统（`build_species_system_SciPy.py`）挂进统一线性系统；
* 多组分 Stefan + Σ h_k J_k 的焓扩散；
* PETSc / GMRES / JFNK 后端替换；
* 动网格（真正用 Rd 重构 Grid1D）。

先按上面 12.1–12.4 把 **“单组分 + 导热 + 潜热 + Stefan + Rd 收缩”** 在时间上跑起来，
有一个能连续走几百步、不秒爆的主循环，后面再往里面加花活，否则你只是在一堆静态方程上反复换边界条件，没法验证全局行为。

---

总结一下：

* 当前建议的 Step 12 局部路线 = **先搞 timestepper 骨架 + 接气相/界面/半径系统 + 串液相温度 + 最小输出与单步测试**。
* 多组分 / 焓扩散 / Yg 耦合，这些全部推到后面的 Step 13，当成一次“接口级别大升级”统一做。

你要是愿意，下一步我可以直接把 `solvers/timestepper.py` 的**骨架说明**写成一份 md（跟 Step 11 那种风格一样），你继续丢给 Codex 填实现。
